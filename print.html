<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-study-log</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="generic_trait_liftime/june.html"><strong aria-hidden="true">1.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generic_trait_liftime/generic.html"><strong aria-hidden="true">1.1.</strong> ジェネリックなデータ型</a></li><li class="chapter-item expanded "><a href="generic_trait_liftime/trait.html"><strong aria-hidden="true">1.2.</strong> トレイト：共通の振る舞いを定義する</a></li><li class="chapter-item expanded "><a href="generic_trait_liftime/lifetime.html"><strong aria-hidden="true">1.3.</strong> ライフタイムで参照を検証する</a></li></ol></li><li class="chapter-item expanded "><a href="auto_tests/writing_automated_tests.html"><strong aria-hidden="true">2.</strong> 自動テストを書く</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="auto_tests/how_to_wirite_tests.html"><strong aria-hidden="true">2.1.</strong> テストの記述法</a></li><li class="chapter-item expanded "><a href="auto_tests/control_how_test_are_executed.html"><strong aria-hidden="true">2.2.</strong> テストの実行のされ方を制御する</a></li><li class="chapter-item expanded "><a href="auto_tests/systematization_of_testing.html"><strong aria-hidden="true">2.3.</strong> テストの体系化</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">rust-study-log</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ジェネリック型トレイトライフタイム"><a class="header" href="#ジェネリック型トレイトライフタイム">ジェネリック型、トレイト、ライフタイム</a></h1>
<p>全てのプログラミング言語には、概念の重複を効率的に扱う道具があります。Rustにおいて、そのような道具の一つがジェネリクスです。 ジェネリクスは、具体型や他のプロパティの抽象的な代役です。コード記述の際、コンパイルやコード実行時に、 ジェネリクスの位置に何が入るかを知ることなく、ジェネリクスの振る舞いや他のジェネリクスとの関係を表現できるのです。</p>
<p>関数が未知の値の引数を取り、同じコードを複数の具体的な値に対して走らせるように、 i32やStringなどの具体的な型の代わりに何かジェネリックな型の引数を取ることができます。 実際、第6章でOption<T>、第8章でVec<T>とHashMap&lt;K, V&gt;、第9章でResult&lt;T, E&gt;を既に使用しました。 この章では、独自の型、関数、メソッドをジェネリクスとともに定義する方法を探究します！</p>
<p>まず、関数を抽出して、コードの重複を減らす方法を確認しましょう。次に同じテクニックを活用して、 引数の型のみが異なる2つの関数からジェネリックな関数を生成します。また、 ジェネリックな型を構造体やenum定義で使用する方法も説明します。</p>
<p>それから、トレイトを使用して、ジェネリックな方法で振る舞いを定義する方法を学びます。 ジェネリックな型にトレイトを組み合わせることで、ジェネリックな型を、単にあらゆる型に対してではなく、特定の振る舞いのある型のみに制限できます。</p>
<p>最後に、ライフタイムを議論します。ライフタイムとは、コンパイラに参照がお互いにどう関係しているかの情報を与える一種のジェネリクスです。 ライフタイムのおかげでコンパイラに参照が有効であることを確認してもらうことを可能にしつつ、多くの場面で値を借用できます。</p>
<h2 id="関数を抽出することで重複を取り除く"><a class="header" href="#関数を抽出することで重複を取り除く">関数を抽出することで重複を取り除く</a></h2>
<p>ジェネリクスの記法に飛び込む前にまずは、関数を抽出することでジェネリックな型が関わらない重複を取り除く方法を見ましょう。 そして、このテクニックを適用してジェネリックな関数を抽出するのです！重複したコードを認識して関数に抽出できるのと同じように、 ジェネリクスを使用できる重複コードも認識し始めるでしょう。</p>
<p>リスト10-1に示したように、リスト内の最大値を求める短いプログラムを考えてください。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    // 最大値は{}です
    println!(&quot;The largest number is {}&quot;, largest);
 assert_eq!(largest, 100);
}
</code></pre></pre>
<p>リスト10-1: 数字のリストから最大値を求めるコード</p>
<p>このコードは、整数のリストを変数number_listに格納し、リストの最初の数字をlargestという変数に配置しています。 それからリストの数字全部を走査し、現在の数字がlargestに格納された数値よりも大きければ、 その変数の値を置き換えます。ですが、現在の数値が今まで見た最大値よりも小さければ、 変数は変わらず、コードはリストの次の数値に移っていきます。リストの数値全てを吟味した後、 largestは最大値を保持しているはずで、今回は100になります。</p>
<p>2つの異なる数値のリストから最大値を発見するには、リスト10-1のコードを複製し、 プログラムの異なる2箇所で同じロジックを使用できます。リスト10-2のようにですね。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p>リスト10-2: 2つの数値のリストから最大値を探すコード</p>
<p>このコードは動くものの、コードを複製することは退屈ですし、間違いも起きやすいです。また、 コードを変更したい時に複数箇所、更新しなければなりません。</p>
<p>この重複を排除するには、引数で与えられた整数のどんなリストに対しても処理が行える関数を定義して抽象化できます。 この解決策によりコードがより明確になり、リストの最大値を探すという概念を抽象的に表現させてくれます。</p>
<p>リスト10-3では、最大値を探すコードをlargestという関数に抽出しました。リスト10-1のコードは、 たった1つの特定のリストからだけ最大値を探せますが、それとは異なり、このプログラムは2つの異なるリストから最大値を探せます。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
   assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
   assert_eq!(result, 6000);
}
</code></pre></pre>
<p>リスト10-3: 2つのリストから最大値を探す抽象化されたコード</p>
<p>largest関数にはlistと呼ばれる引数があり、これは、関数に渡す可能性のある、あらゆるi32値の具体的なスライスを示します。 結果的に、関数呼び出しの際、コードは渡した特定の値に対して走るのです。</p>
<p>まとめとして、こちらがリスト10-2のコードからリスト10-3に変更するのに要したステップです:</p>
<p>重複したコードを見分ける。
重複コードを関数本体に抽出し、コードの入力と戻り値を関数シグニチャで指定する。
重複したコードの2つの実体を代わりに関数を呼び出すように更新する。
次は、この同じ手順をジェネリクスでも踏んで異なる方法でコードの重複を減らします。 関数本体が特定の値ではなく抽象的なlistに対して処理できたのと同様に、 ジェネリクスは抽象的な型に対して処理するコードを可能にしてくれます。</p>
<p>例えば、関数が2つあるとしましょう: 1つはi32値のスライスから最大の要素を探し、1つはchar値のスライスから最大要素を探します。 この重複はどう排除するのでしょうか？答えを見つけましょう！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ジェネリックなデータ型"><a class="header" href="#ジェネリックなデータ型">ジェネリックなデータ型</a></h1>
<p>関数シグニチャや構造体などの要素の定義を生成するのにジェネリクスを使用することができ、 それはさらに他の多くの具体的なデータ型と使用することもできます。まずは、 ジェネリクスで関数、構造体、enum、メソッドを定義する方法を見ましょう。それから、 ジェネリクスがコードのパフォーマンスに与える影響を議論します。</p>
<h2 id="関数定義では"><a class="header" href="#関数定義では">関数定義では</a></h2>
<p>ジェネリクスを使用する関数を定義する時、通常、引数や戻り値のデータ型を指定する関数のシグニチャにジェネリクスを配置します。 そうすることでコードがより柔軟になり、コードの重複を阻止しつつ、関数の呼び出し元により多くの機能を提供します。</p>
<p>largest関数を続けます。リスト10-4はどちらもスライスから最大値を探す2つの関数を示しています。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
   assert_eq!(result, 100);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
   assert_eq!(result, 'y');
}
</code></pre></pre>
<p>リスト10-4: 名前とシグニチャの型のみが異なる2つの関数</p>
<p>largest_i32関数は、リスト10-3で抽出したスライスから最大のi32を探す関数です。 largest_char関数は、スライスから最大のcharを探します。関数本体には同じコードがあるので、 単独の関数にジェネリックな型引数を導入してこの重複を排除しましょう。</p>
<p>これから定義する新しい関数の型を引数にするには、ちょうど関数の値引数のように型引数に名前をつける必要があります。 型引数の名前にはどんな識別子も使用できますが、Tを使用します。というのも、慣習では、 Rustの引数名は短く(しばしばたった1文字になります)、Rustの型の命名規則がキャメルケースだからです。 &quot;type&quot;の省略形なので、Tが多くのRustプログラマの既定の選択なのです。</p>
<p>関数の本体で引数を使用するとき、コンパイラがその名前の意味を把握できるようにシグニチャでその引数名を宣言しなければなりません。 同様に、型引数名を関数シグニチャで使用する際には、使用する前に型引数名を宣言しなければなりません。 ジェネリックなlargest関数を定義するために、型名宣言を山カッコ(&lt;&gt;)内、関数名と引数リストの間に配置してください。 こんな感じに:</p>
<pre><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>この定義は以下のように解読します: 関数largestは、なんらかの型Tに関してジェネリックであると。 この関数にはlistという引数が1つあり、これは型Tの値のスライスです。 largest関数は同じT型の値を返します。</p>
<p>リスト10-5は、シグニチャにジェネリックなデータ型を使用してlargest関数定義を組み合わせたものを示しています。 このリストはさらに、この関数をi32値かchar値のどちらかで呼べる方法も表示しています。 このコードはまだコンパイルできないことに注意してください。ですが、この章の後ほど修正します。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>リスト10-5: ジェネリックな型引数を使用するものの、まだコンパイルできないlargest関数の定義</p>
<p>直ちにこのコードをコンパイルしたら、以下のようなエラーが出ます:</p>
<pre><code>error[E0369]: binary operation `&gt;` cannot be applied to type `T`
(エラー: 2項演算`&gt;`は、型`T`に適用できません)
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
  (注釈: `std::cmp::PartialOrd`の実装が`T`に対して存在しない可能性があります)
</code></pre>
<p>注釈がstd::cmp::PartialOrdに触れています。これは、トレイトです。トレイトについては、次の節で語ります。 とりあえず、このエラーは、largestの本体は、Tがなりうる全ての可能性のある型に対して動作しないと述べています。 本体で型Tの値を比較したいので、値が順序付け可能な型のみしか使用できないのです。比較を可能にするために、 標準ライブラリには型に実装できるstd::cmp::PartialOrdトレイトがあります(このトレイトについて詳しくは付録Cを参照されたし)。 ジェネリックな型が特定のトレイトを持つと指定する方法は「トレイト境界」節で習うでしょうが、 先にジェネリックな型引数を使用する他の方法を探究しましょう。</p>
<h2 id="構造体定義では"><a class="header" href="#構造体定義では">構造体定義では</a></h2>
<p>構造体を定義して&lt;&gt;記法で1つ以上のフィールドにジェネリックな型引数を使用することもできます。 リスト10-6は、Point<T>構造体を定義してあらゆる型のxとy座標を保持する方法を示しています。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p>リスト10-6: 型Tのxとy値を保持するPoint<T>構造体</p>
<p>構造体定義でジェネリクスを使用する記法は、関数定義のものと似ています。まず、山カッコ内に型引数の名前を構造体名の直後に宣言します。 そうすると、本来具体的なデータ型を記述する構造体定義の箇所に、ジェネリックな型を使用できます。</p>
<p>ジェネリックな型を1つだけ使用してPoint<T>を定義したので、この定義は、Point<T>構造体がなんらかの型Tに関して、 ジェネリックであると述べていて、その型がなんであれ、xとyのフィールドは両方その同じ型になっていることに注意してください。 リスト10-7のように、異なる型の値のあるPoint<T>のインスタンスを生成すれば、コードはコンパイルできません。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p>リスト10-7: どちらも同じジェネリックなデータ型Tなので、xとyというフィールドは同じ型でなければならない</p>
<p>この例で、xに整数値5を代入すると、このPoint<T>のインスタンスに対するジェネリックな型Tは整数になるとコンパイラに知らせます。 それからyに4.0を指定する時に、このフィールドはxと同じ型と定義したはずなので、このように型不一致エラーが出ます:</p>
<pre><code>error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<p>xとyが両方ジェネリックだけれども、異なる型になり得るPoint構造体を定義するには、 複数のジェネリックな型引数を使用できます。例えば、リスト10-8では、Pointの定義を変更して、 型TとUに関してジェネリックにし、xが型Tで、yが型Uになります。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p>リスト10-8: Point&lt;T, U&gt;は2つの型に関してジェネリックなので、xとyは異なる型の値になり得る</p>
<p>これで、示されたPointインスタンスは全部使用可能です！所望の数だけ定義でジェネリックな型引数を使用できますが、 数個以上使用すると、コードが読みづらくなります。コードで多くのジェネリックな型が必要な時は、 コードの小分けが必要なサインかもしれません。</p>
<h2 id="enum定義では"><a class="header" href="#enum定義では">enum定義では</a></h2>
<p>構造体のように、列挙子にジェネリックなデータ型を保持するenumを定義することができます。 標準ライブラリが提供しているOption<T> enumをもう一度見ましょう。このenumは第6章で使用しました:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
}
</code></pre></pre>
<p>この定義はもう、あなたにとってより道理が通っているはずです。ご覧の通り、Option<T>は、 型Tに関してジェネリックで2つの列挙子のあるenumです: その列挙子は、型Tの値を保持するSomeと、 値を何も保持しないNoneです。Option<T> enumを使用することで、オプショナルな値があるという抽象的な概念を表現でき、 Option<T>はジェネリックなので、オプショナルな値の型に関わらず、この抽象を使用できます。</p>
<p>enumも複数のジェネリックな型を使用できます。第9章で使用したResult enumの定義が一例です:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
}
</code></pre></pre>
<p>Result enumは2つの型T、Eに関してジェネリックで、2つの列挙子があります: 型Tの値を保持するOkと、 型Eの値を保持するErrです。この定義により、Result enumを、成功する(なんらかの型Tの値を返す)か、 失敗する(なんらかの型Eのエラーを返す)可能性のある処理がある、あらゆる箇所に使用するのが便利になります。 事実、ファイルを開くのに成功した時にTに型std::fs::Fileが入り、ファイルを開く際に問題があった時にEに型std::io::Errorが入ったものが、 リスト9-3でファイルを開くのに使用したものです。</p>
<p>自分のコード内で、保持している値の型のみが異なる構造体やenum定義の場面を認識したら、 代わりにジェネリックな型を使用することで重複を避けることができます。</p>
<h2 id="メソッド定義では"><a class="header" href="#メソッド定義では">メソッド定義では</a></h2>
<p>(第5章のように、)定義にジェネリックな型を使うメソッドを構造体やenumに実装することもできます。リスト10-9は、 リスト10-6で定義したPoint<T>構造体にxというメソッドを実装したものを示しています。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p>リスト10-9: 型Tのxフィールドへの参照を返すxというメソッドをPoint<T>構造体に実装する</p>
<p>ここで、フィールドxのデータへの参照を返すxというメソッドをPoint<T>に定義しました。</p>
<p>implの直後にTを宣言しなければならないことに注意してください。こうすることで、型Point<T>にメソッドを実装していることを指定するために、Tを使用することができます。 implの後にTをジェネリックな型として宣言することで、コンパイラは、Pointの山カッコ内の型が、 具体的な型ではなくジェネリックな型であることを認識できるのです。</p>
<p>例えば、ジェネリックな型を持つPoint<T>インスタンスではなく、Point<f32>だけにメソッドを実装することもできるでしょう。 リスト10-10では、具体的な型f32を使用しています。つまり、implの後に型を宣言しません。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
}
</code></pre></pre>
<p>リスト10-10: ジェネリックな型引数Tに対して特定の具体的な型がある構造体にのみ適用されるimplブロック</p>
<p>このコードは、Point<f32>にはdistance_from_originというメソッドが存在するが、 Tがf32ではないPoint<T>の他のインスタンスにはこのメソッドが定義されないことを意味します。 このメソッドは、この点が座標(0.0, 0.0)の点からどれだけ離れているかを測定し、 浮動小数点数にのみ利用可能な数学的処理を使用します。</p>
<p>構造体定義のジェネリックな型引数は、必ずしもその構造体のメソッドシグニチャで使用するものと同じにはなりません。 例を挙げれば、リスト10-11は、リスト10-8のPoint&lt;T, U&gt;にメソッドmixupを定義しています。 このメソッドは、他のPointを引数として取り、この引数はmixupを呼び出しているselfのPointとは異なる型の可能性があります。 このメソッドは、(型Tの)selfのPointのx値と渡した(型Wの)Pointのy値から新しいPointインスタンスを生成します。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p>リスト10-11: 構造体定義とは異なるジェネリックな型を使用するメソッド</p>
<p>mainで、x(値は5)にi32、y(値は10.4)にf64を持つPointを定義しました。p2変数は、 x(値は&quot;Hello&quot;)に文字列スライス、y(値はc)にcharを持つPoint構造体です。 引数p2でp1にmixupを呼び出すと、p3が得られ、xはi32になります。xはp1由来だからです。 p3変数のyは、charになります。yはp2由来だからです。println!マクロの呼び出しは、 p3.x = 5, p3.y = cと出力するでしょう。</p>
<p>この例の目的は、一部のジェネリックな引数はimplで宣言され、他の一部はメソッド定義で宣言される場面をデモすることです。 ここで、ジェネリックな引数TとUはimplの後に宣言されています。構造体定義にはまるからです。 ジェネリックな引数VとWはfn mixupの後に宣言されています。何故なら、このメソッドにしか関係ないからです。</p>
<h2 id="ジェネリクスを使用したコードのパフォーマンス"><a class="header" href="#ジェネリクスを使用したコードのパフォーマンス">ジェネリクスを使用したコードのパフォーマンス</a></h2>
<p>ジェネリックな型引数を使用すると、実行時にコストが発生するのかな、と思うかもしれません。 嬉しいことにRustでは、ジェネリクスを、具体的な型があるコードよりもジェネリックな型を使用したコードを実行するのが遅くならないように実装しています。</p>
<p>コンパイラはこれを、ジェネリクスを使用しているコードの単相化をコンパイル時に行うことで達成しています。 単相化(monomorphization)は、コンパイル時に使用されている具体的な型を入れることで、 ジェネリックなコードを特定のコードに変換する過程のことです。</p>
<p>この過程において、コンパイラは、リスト10-5でジェネリックな関数を生成するために使用した手順と真逆のことをしています: コンパイラは、ジェネリックなコードが呼び出されている箇所全部を見て、 ジェネリックなコードが呼び出されている具体的な型のコードを生成するのです。</p>
<p>標準ライブラリのOption<T> enumを使用する例でこれが動作する方法を見ましょう:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
let integer = Some(5);
let float = Some(5.0);
}
</code></pre></pre>
<p>コンパイラがこのコードをコンパイルすると、単相化を行います。その過程で、コンパイラはOption<T>のインスタンスに使用された値を読み取り、 2種類のOption<T>を識別します: 一方はi32で、もう片方はf64です。そのように、 コンパイラは、Option<T>のジェネリックな定義をOption_i32とOption_f64に展開し、 それにより、ジェネリックな定義を特定の定義と置き換えます。</p>
<p>単相化されたバージョンのコードは、以下のようになります。ジェネリックなOption<T>が、 コンパイラが生成した特定の定義に置き換えられています:</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Rustでは、ジェネリックなコードを各インスタンスで型を指定したコードにコンパイルするので、 ジェネリクスを使用することに対して実行時コストを払うことはありません。コードを実行すると、 それぞれの定義を手作業で複製した時のように振る舞います。単相化の過程により、 Rustのジェネリクスは実行時に究極的に効率的になるのです。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="2022-年-6-月-29-日"><a class="header" href="#2022-年-6-月-29-日">2022 年 6 月 29 日</a></h1>
<h2 id="今日の学習内容"><a class="header" href="#今日の学習内容">今日の学習内容</a></h2>
<p>トレイト：共通の振る舞いを定義する</p>
<h3 id="トレイト共通の振る舞いを定義する"><a class="header" href="#トレイト共通の振る舞いを定義する">トレイト:共通の振る舞いを定義する</a></h3>
<p>トレイトは、Rust コンパイラに、特定の型に存在し、他の型と共有できる機能について知らせます。
トレイトを使用すると、共通の振る舞いを抽象的に定義できます。
トレイト境界を使用すると、あるジェネリックが、特定の振る舞いをもつあらゆる型になり得ることを指定できます。</p>
<blockquote>
<p>トレイトの機能としては</p>
<p>・Rust コンパイラに知らせる（特定の型に存在し、他の方と共有できる機能について）</p>
<p>・共通の振る舞いを抽象的に定義できます</p>
<p>・トレイト境界というのがある</p>
<p>・とあるジェネリックが、特定の振る舞いをもつあらゆる型になり得る</p>
</blockquote>
<p>という機能があったりするということです。</p>
<blockquote>
<p>注釈：違いはあるものの、トレイトは他の言語でよくインターフェイスと呼ばれる機能に類似しています。</p>
</blockquote>
<h4 id="トレイトを定義する"><a class="header" href="#トレイトを定義する">トレイトを定義する</a></h4>
<p>型の振る舞いは、その型に対して呼び出せるメソッドから構成されます。異なる型は、それらの型全てに対して同じメソッドを呼び出せるなら、同じ振る舞いを共有することになります。トレイト定義は、メソッドシグニチャをあるグループにまとめ、なんらかの目的を達成するのに必要な一連の振る舞いを定義する手段です。</p>
<blockquote>
<p>基本的な考え方としては型の定義が違うけど、実際のロジックは同じという状況が発生すると、同じコードを再度書くのが DRY（Don't Repeat Yourself)の原則から外れるからやめた方がいいよということです。（別に使っても問題ないです。一緒に働く仲間からは嫌われる可能性があるので、仲良くしたい人はうまく書けないことを伝えておくか、共通化が必要になったときにどのようにしたらいいのか？テックリードあたりに確認するのがいいです）</p>
<p>で、そのテックリードとかが「知るか！」という場合はあっていないので職場を離れましょう。基本的にコード戦略等は指揮をとる人に確認します。自分勝手なコードを書かないように、この時強い言葉（パンチラインの効いた言葉）を使う人とは仕事をするのは要注意です。（京都的な嫌味な言い回しも気をつけましょう）「結構学生の頃頑張ってたんですね。」とかは「お前のコードは学生レベルだからな」という言い回しですので、非常に気をつけましょう。</p>
</blockquote>
<p>例えば、いろんな種類や量のテキストを保持する複数の構造体があるとしましょう:特定の場所から送られる新しいニュースを保持する<code>NewsArticle</code>と、新規ツイートか、リツイートか、はたまた他のツイートへのリプライなのかを示すメタデータを伴う最大で 280 文字までの<code>Tweet</code>です。</p>
<p><code>NewsArticle</code>または<code>Tweet</code>インスタンスに保存されているデータのサマリーを表示できるメディアアグリゲータライブラリを作成します。これをするには、各型のサマリーが必要で、インスタンスで<code>summarize</code>メソッドを呼び出してサマリーを要求する必要があります。リスト 10-12 は、この振る舞いを表現する<code>Summary</code>トレイトの定義を表示しています。</p>
<blockquote>
<p>要するにここではツイートやニュース記事の統計データと目次を表示できるライブラリを作ろうとします。アグリゲートは「集める」や「合計する」「集計する」という意味があります。なのでイメージとしては 2ch まとめサイトがいいかと思います。</p>
</blockquote>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>リスト 10-12: <code>summarize</code>メソッドで提供される振る舞いからなる<code>Summary</code>トレイト</strong></p>
<p>ここでは、trait キーワード、それからトレイト名を使用してトレイトを定義していて、その名前は今回の場合、Summary です。波括弧の中にこのトレイトを実装する型の振る舞いを記述するメソッドシグニチャを定義し、今回の場合は、fn summarize(&amp;self) -&gt; String です。</p>
<blockquote>
<p>pub trait と宣言することで外部ファイルでも使用できる trait（振る舞い）を定義することができます。
この場合の振る舞いは Summary と言う振る舞いでその中身は fn summarize(&amp;self) -&gt; String
と言う返り値が文字列の配列になる形です。</p>
</blockquote>
<p>メソッドシグニチャの後に、波括弧内に実装を提供する代わりに、セミコロンを使用しています。このトレイトを実装する型はそれぞれ、メソッドの本体に独自の振る舞いを提供しなければなりません。コンパイラにより、Summary トレイトを保持するあらゆる型に、このシグニチャと全く同じメソッド summarize が定義されていることが強制されます。</p>
<p>トレイトには、本体に複数のメソッドを含むことができます:メソッドシグニチャは行ごとに並べられ、各行はセミコロンで終わります。</p>
<h4 id="トレイトを型に実装する"><a class="header" href="#トレイトを型に実装する">トレイトを型に実装する</a></h4>
<p>今や Summary トレイトを使用して目的の動作を定義できたので、
メディアアグリゲータでこれを型に実装できます。
リスト 10-13 は、Summary トレイトを NewsArticle 構造体上に実装したもので、
ヘッドライン、著者、そして地域情報を使って summarize の戻り値を作っています。
Tweet 構造体に関しては、ツイートの内容が既に 280 文字に制限されていると仮定して、
ユーザー名の後にツイートのテキスト全体が続くものとして summarize を定義します。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">   pub trait Summary {
</span><span class="boring">       fn summarize(&amp;self) -&gt; String
</span><span class="boring">   }
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>型にトレイトを実装することは、普通のメソッドを実装することに似ています。
違いは、impl の後に、実装したいトレイトの名前を置き、それから for キーワード、
さらにトレイトの実装対象の型の名前を指定することです。
impl ブロック内に、トレイト定義で定義したメソッドシグニチャを置きます。
各シグニチャの後にセミコロンを追記するのではなく、波括弧を使用し、
メソッド本体に特定の型のトレイトのメソッドに欲しい特定の振る舞いを入れます。</p>
<p>トレイトを実装後、普通のメソッド同様に NewsArticle や Tweet のインスタンスに対してこのメソッドを呼び出せます。 こんな感じで:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use chapter10::{self, Summary, Tweet};
</span>
<span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre></pre>
<p>このコードは、1 new tweet: horse_ebooks: of course, as you probably already know, people と出力します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>感想メモ：</p>
<p>ここで self.username と self.content の 2 つに関してフォーマットを実施すると言う内容になっています。
ですので、Tweet については username と content については自身の文字列の引数を受け取って関数を実行します。
ポイントはあくまでも共通化処理なので、一つずつの構造体のキー名に対して impl を実装することも可能ですが、
こちらの方が都合がいいのでは？と言うのが感想です（甘いかもしれませんが。）</p>
</blockquote>
<p>リスト 10-13 で Summary トレイトと NewArticle、Tweet 型を同じ lib.rs に定義したので、
全部同じスコープにあることに注目してください。
この lib.rs を aggregator と呼ばれるクレート専用にして、
誰か他の人が私たちのクレートの機能を活用して自分のライブラリのスコープに
定義された構造体に Summary トレイトを実装したいとしましょう。
まず、トレイトをスコープに取り込む必要があるでしょう。</p>
<p>use aggregator::Summary;</p>
<p>と指定してそれを行えば、これにより、自分の型に Summary を実装することが可能になるでしょう。
Summary トレイトは、他のクレートが実装するためには、公開トレイトである必要があり、
ここでは、リスト 10-12 の trait の前に、pub キーワードを置いたのでそうなっています。</p>
<p>トレイト実装で注意すべき制限の 1 つは、トレイトか対象の型が自分のクレートに固有(local)である時のみ、
型に対してトレイトを実装できるということです。
例えば、Display のような標準ライブラリのトレイトを aggregator クレートの機能の一部として、
Tweet のような独自の型に実装できます。
型 Tweet が aggregator クレートに固有だからです。
また、Summary を aggregator クレートで Vec<T>に対して実装することもできます。
トレイト Summary は、aggregator クレートに固有だからです。</p>
<p>しかし、外部のトレイトを外部の型に対して実装することはできません。
例として、aggregator クレート内で Vec<T>に対して Display トレイトを実装することはできません。
Display と Vec<T>は標準ライブラリで定義され、aggregator クレートに固有ではないからです。
この制限は、コヒーレンス(coherence)、
特に孤児のルール(orphan rule)と呼ばれるプログラムの特性の一部で、
親の型が存在しないためにそう命名されました。
この規則により、他の人のコードが自分のコードを壊したり、
その逆が起きないことを保証してくれます。
この規則がなければ、2 つのクレートが同じ型に対して同じトレイトを実装できてしまい、
コンパイラはどちらの実装を使うべきかわからなくなってしまうでしょう。</p>
<blockquote>
<p>■ コヒーレンス(Coherence：可干渉性)
コヒーレンスとは、波が重なり合ったときの干渉縞の作り易さを示します。</p>
<p>重なり合う波同士の位相、振幅に一定の関係がある場合は、合成された波も一定の位相、振幅をもつので干渉縞ができます。
干渉縞を作れる波をコヒーレントな波といい、レーザ光は代表的なコヒーレントな波（コヒーレント光）です。
一方、位相、振幅がランダムな波は干渉縞を作ることができず、インコヒーレントな波といいます。
電球、LED、SLD、ASE 光源などはインコヒーレントな波（インコヒーレント光）です。</p>
</blockquote>
<blockquote>
<p>ちょっとここ難しいので図式化が必要です。</p>
<p>ここの部分登場人物を整理しないといけないです。</p>
<p>・NewArticle と Tweet と言う二つの型を同じ lib.rs のファイルに定義している</p>
<p>・同じスコープ内にある</p>
<p>・この lib.rs を aggregator と呼ばれるクレート専用にして、誰かの他の人が私たちのクレート機能を活用して自分のライブラリのスコープに定義された構造体に Summary トレイトを実装したいとしましょう。</p>
<p>・まず、トレイトをスコープに取り込む必要があります。</p>
<p>・トレイトを他のクレートが実装するためには定義したトレイトを公開状態にする必要があります。</p>
<p>・トレイト実装で注意すべき制限の 1 つは、トレイトか対象の型が自分のクレートに固有（local）であるときのみ、型に対してトレイトを実装できると言うことです。</p>
<p>・Display のような標準ライブラリのトレイトを aggregator クレートの機能の一部として、Tweet のような独自の型に実装できます。</p>
<p>・型 Tweet が aggregator クレートに固有だからです。</p>
<p>・また Summary を aggregator クレートで Vec<T>に対して実装することもできます。</p>
<p>・トレイト Summary は、aggregator クレートに固有だからです。</p>
<p>・しかし、外部トレイトを外部の型に対して実装することはできません。例として、aggregator クレート内で Vec<T>に対して Display トレイトを実装することはできません。</p>
<p>・Display と Vec<T>は標準ライブラリで定義され、aggregator クレートに固有ではないからです。</p>
<p>・この制限は、コヒーレンス(coherence)、特に孤児のルール(orphan rule)と呼ばれるプログラムの特性の一部で、</p>
<p>・親の型が存在しないためにそう命名されました。この規則により、他の人のコードが自分のコードを壊したり、その逆が起きないことを保証してくれます。この規則がなければ、2 つのクレートが同じ型に対して同じトレイトを実装できてしまい、コンパイラはどちらの実装を使うべきかわからなくなってしましいます。</p>
</blockquote>
<blockquote>
<p>ここのポイント</p>
<p>これは、impl で型とトレイトをくっつける時にお互いが外部の場合で、何かしらのプロジェクトに 10 個ほどクレートを呼び出して、
クレート１から１０までに同じ実装がある場合、コンパイラが「え？全部に同じ impl があるねんけど、どれ呼び出したらええん？」
みたいな感じで困惑するので、それを防ぎましょうね？と言うことですかね？
なのでそれを防ぐ方法として、型、トレイトのどちらか最低一つでも「独自」の定義した内容を盛り込みましょう！
みたいな認識だと思います。</p>
</blockquote>
<h4 id="デフォルト実装"><a class="header" href="#デフォルト実装">デフォルト実装</a></h4>
<p>時として、全ての型の全メソッドに対して実装を要求するのではなく、トレイトの全てあるいは一部のメソッドに対してデフォルトの振る舞いがあると有用です。 そうすれば、特定の型にトレイトを実装する際、各メソッドのデフォルト実装を保持するかオーバーライドするか選べるわけです。</p>
<p>リスト 10-14 は、リスト 10-12 のように、メソッドシグニチャだけを定義するのではなく、 Summary トレイトの summarize メソッドにデフォルトの文字列を指定する方法を示しています。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        // &quot;（もっと読む）&quot;
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">   pub headline: String,
</span><span class="boring">   pub location: String,
</span><span class="boring">   pub author: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">   pub username: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">   pub reply: bool,
</span><span class="boring">   pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">   fn summarize(&amp;self) -&gt; String {
</span><span class="boring">       format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>リスト 10-14: summarize メソッドのデフォルト実装がある Summary トレイトの定義</p>
<p>独自の実装を定義するのではなく、デフォルト実装を利用して NewsArticle のインスタンスをまとめるには、 impl Summary for NewsArticle {}と空の impl ブロックを指定します。</p>
<p>もはや NewsArticle に直接 summarize メソッドを定義してはいませんが、私達はデフォルト実装を提供しており、 NewsArticle は Summary トレイトを実装すると指定しました。そのため、 NewsArticle のインスタンスに対して summarize メソッドを同じように呼び出すことができます。 このように:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        // ペンギンチームがスタンレーカップチャンピオンシップを勝ち取る！
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        // アメリカ、ペンシルベニア州、ピッツバーグ
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        // アイスバーグ
        author: String::from(&quot;Iceburgh&quot;),
        // ピッツバーグ・ペンギンが再度NHL(National Hockey League)で最強のホッケーチームになった
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre></pre>
<p>このコードは、New article available! (Read more...)（新しい記事があります！（もっと読む））と出力します。</p>
<p>summarize にデフォルト実装を用意しても、リスト 10-13 の Tweet の Summary 実装を変える必要はありません。 理由は、デフォルト実装をオーバーライドする記法はデフォルト実装のないトレイトメソッドを実装する記法と同じだからです。</p>
<p>デフォルト実装は、自らのトレイトのデフォルト実装を持たない他のメソッドを呼び出すことができます。 このようにすれば、トレイトは多くの有用な機能を提供しつつ、実装者は僅かな部分しか指定しなくて済むようになります。 例えば、Summary トレイトを、（実装者が）内容を実装しなければならない summarize_author メソッドを持つように定義し、 それから summarize_author メソッドを呼び出すデフォルト実装を持つ summarize メソッドを定義することもできます:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
<span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        // &quot;（{}さんの文章をもっと読む）&quot;
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">   pub username: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">   pub reply: bool,
</span><span class="boring">   pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">   fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">       format!(&quot;@{}&quot;, self.username)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>このバージョンの Summary を使用するために、型にトレイトを実装する際、実装する必要があるのは summarize_author だけです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">   fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">   fn summarize(&amp;self) -&gt; String {
</span><span class="boring">       // &quot;（{}さんの文章をもっと読む）&quot;
</span><span class="boring">       format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">   pub username: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">   pub reply: bool,
</span><span class="boring">   pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>summarize_author 定義後、Tweet 構造体のインスタンスに対して summarize を呼び出せ、 summarize のデフォルト実装は、私達が提供した summarize_author の定義を呼び出すでしょう。 summarize_author を実装したので、追加のコードを書く必要なく、Summary トレイトは、 summarize メソッドの振る舞いを与えてくれました。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre></pre>
<p>このコードは、1 new tweet: (Read more from @horse_ebooks...)（1 つの新しいツイート：（@horse_ebooks さんの文章をもっと読む））と出力します。</p>
<p>デフォルト実装を、そのメソッドをオーバーライドしている実装から呼び出すことはできないことに注意してください。</p>
<blockquote>
<p>感想</p>
<p>鬼難しい。デフォルト実装のポイントがさっぱりわからん。
とりあえず今のところわかっているのは、デフォルト実装という機能を使うと impl の時に宣言しなくてもいいことはわかった。
ただ何がデフォルト実装で、何がデフォルト実装ではないのか？の区別がつかない。</p>
</blockquote>
<p>トレイトは関数名と引数と返り値の型情報だけで構成される。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>トレイトのデフォルト実装は関数名と引数と返り値の型情報と、関数の実行内容も記載されます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn summarize_author(&amp;self) -&gt; String; // トレイトの実装

pub trait Summary { // デフォルトトレイトの実装
    fn summarize(&amp;self) -&gt; String {
        // &quot;（もっと読む）&quot;
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>デフォルト実装はトレイトの定義時に処理も記載しているかどうかで判別します。</p>
</blockquote>
<h3 id="引数としてのトレイト"><a class="header" href="#引数としてのトレイト">引数としてのトレイト</a></h3>
<p>トレイトを定義し実装する方法はわかったので、
トレイトを使っていろんな種類の型を受け付ける関数を定義する方法を学んでいきましょう。</p>
<p>たとえば、Listing 10-13 では、NewsArticle と Tweet 型に Summary トレイトを実装しました。
ここで、引数の item の summarize メソッドを呼ぶ関数 notify を定義することができます。
ただし、引数 item は Summary トレイトを実装しているような何らかの型であるとします。
このようなことをするためには、impl Trait 構文を使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>引数の item には、具体的な型の代わりに、impl キーワードとトレイト名を指定します。
この引数は、指定されたトレイトを実装しているあらゆる型を受け付けます。
notify の中身では、summarize のような、Summary トレイトに由来する item のあらゆるメソッドを呼び出すことができます。
私達は、notify を呼びだし、NewsArticle か Tweet のどんなインスタンスでも渡すことができます。
この関数を呼び出すときに、String や i32 のような他の型を渡すようなコードはコンパイルできません。
なぜなら、これらの型は Summary を実装していないからです。</p>
<blockquote>
<p>引数に対してトレイトを実装することができて、引数にトレイトの振る舞いを付与することができるので、
実行内容にトレイトの振る舞いの関数を使用することができる。</p>
</blockquote>
<h4 id="トレイト境界構文"><a class="header" href="#トレイト境界構文">トレイト境界構文</a></h4>
<p>impl Trait 構文は単純なケースを解決しますが、実はより長いトレイト境界 (trait bound) と呼ばれる姿の糖衣構文 (syntax sugar) なのです。 それは以下のようなものです：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    // 速報！ {}
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>この「より長い」姿は前節の例と等価ですが、より冗長です。
山カッコの中にジェネリックな型引数の宣言を書き、型引数の後ろにコロンを挟んでトレイト境界を置いています。</p>
<p>簡単なケースに対し、impl Trait 構文は便利で、コードを簡潔にしてくれます。
そうでないケースの場合、トレイト境界構文を使えば複雑な状態を表現できます。
たとえば、Summary を実装する 2 つのパラメータを持つような関数を考えることができます。
impl Trait 構文を使うとこのようになるでしょう：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
<span class="boring">}
</span></code></pre></pre>
<p>この関数が受け取る item1 と item2 の型が（どちらも Summary を実装する限り）異なっても良いとするならば、
impl Trait は適切でしょう。
両方の引数が同じ型であることを強制することは、以下のようにトレイト境界を使ってのみ表現可能です：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
<span class="boring">}
</span></code></pre></pre>
<p>引数である item1 と item2 の型としてジェネリックな型 T を指定しました。
これにより、item1 と item2 として関数に渡される値の具体的な型が同一でなければならない、
という制約を与えています。</p>
<blockquote>
<p>ここはあくまでもトレイトを元々の表現方法であって、簡潔に実装できるようになっているので、原理ぐらいにとどめておくほうがいい。</p>
</blockquote>
<h4 id="複数のトレイト境界を構文で指定する"><a class="header" href="#複数のトレイト境界を構文で指定する">複数のトレイト境界を+構文で指定する</a></h4>
<p>複数のトレイト境界も指定できます。
たとえば、notify に summarize メソッドに加えて item の画面出力形式（ディスプレイフォーマット）を使わせたいとします。
その場合は、notify の定義に item は Display と Summary の両方を実装していなくてはならないと指定することになります。
これは、以下のように+構文で行うことができます：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;(impl Summary + Display)) {
<span class="boring">}
</span></code></pre></pre>
<p>+構文はジェネリック型につけたトレイト境界に対しても使えます：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
<span class="boring">}
</span></code></pre></pre>
<p>これら 2 つのトレイト境界が指定されていれば、notify の中では summarize を呼び出すことと、
{}を使って item をフォーマットすることの両方が行なえます。</p>
<h4 id="where-句を使ったより明確なトレイト境界"><a class="header" href="#where-句を使ったより明確なトレイト境界">where 句を使ったより明確なトレイト境界</a></h4>
<p>あまりたくさんのトレイト境界を使うことには欠点もあります。
それぞれのジェネリック（な型）がそれぞれのトレイト境界をもつので、
複数のジェネリック型の引数をもつ関数は、関数名と引数リストの間に大量のトレイト境界に関する情報を含むことがあります。
これでは関数のシグネチャが読みにくくなってしまいます。
このため、Rust はトレイト境界を関数シグネチャの後の where 句の中で指定するという別の構文を用意しています。 なので、このように書く：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
<span class="boring">}
</span></code></pre></pre>
<p>代わりに、where 句を使い、このように書くことができます：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
<span class="boring">}
</span></code></pre></pre>
<p>この関数シグニチャは、よりさっぱりとしています。
トレイト境界を多く持たない関数と同じように、関数名、引数リスト、戻り値の型が一緒になって近くにあるからですね。</p>
<blockquote>
<p>基本的に書きやすくするためにあるものと思っておけばいい。実際に使うときになったら考えましょう。</p>
</blockquote>
<h3 id="トレイトを実装している型を返す"><a class="header" href="#トレイトを実装している型を返す">トレイトを実装している型を返す</a></h3>
<p>以下のように、impl Trait 構文を戻り値型のところで使うことにより、あるトレイトを実装する何らかの型を返すことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>戻り値の型として impl Summary を使うことにより、具体的な型が何かを言うことなく、
returns_summarizable 関数は Summary トレイトを実装している何らかの型を返すのだ、と指定することができます。
今回 returns_summarizable は Tweet を返しますが、この関数を呼び出すコードはそのことを知りません。</p>
<p>実装しているトレイトだけで戻り値型を指定できることは、13 章で学ぶ、クロージャとイテレータを扱うときに特に便利です。
クロージャとイテレータの作り出す型は、コンパイラだけが知っているものであったり、指定するには長すぎるものであったりします。
impl Trait 構文を使えば、非常に長い型を書くことなく、ある関数は Iterator トレイトを実装するある型を返すのだ、
と簡潔に指定することができます。</p>
<p>ただし、impl Trait は一種類の型を返す場合にのみ使えます。
たとえば、以下のように、戻り値の型は impl Summary で指定しつつ、NewsArticle か Tweet を返すようなコードは失敗します：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>NewsArticle か Tweet を返すというのは、コンパイラの impl Trait 構文の実装まわりの制約により許されていません。
このような振る舞いをする関数を書く方法は、17 章のトレイトオブジェクトで異なる型の値を許容する節で学びます。</p>
<blockquote>
<p>返り値のトレイトは一種類だけ。条件によって if 文制御ができない</p>
</blockquote>
<h3 id="トレイト境界で-largest-関数を修正する"><a class="header" href="#トレイト境界で-largest-関数を修正する">トレイト境界で largest 関数を修正する</a></h3>
<p>ジェネリックな型引数の境界で使用したい振る舞いを指定する方法がわかったので、リスト 10-5 に戻って、
ジェネリックな型引数を使用する largest 関数の定義を修正しましょう！
最後にそのコードを実行しようとした時、 こんなエラーが出ていました:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>largest の本体で、大なり演算子(&gt;)を使用して型 T の 2 つの値を比較しようとしていました。
この演算子は、 標準ライブラリトレイトの std::cmp::PartialOrd でデフォルトメソッドとして定義されているので、
largest 関数が、比較できるあらゆる型のスライスに対して動くようにするためには、
T のトレイト境界に PartialOrd を指定する必要があります。
PartialOrd は prelude に含まれているので、これをスコープに導入する必要はありません。
largest のシグニチャを以下のように変えてください:</p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>今回のコンパイルでは、別のエラーが出てきます：</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
（エラー[E0508]： 型`[T]`をもつ、非コピーのスライスからのムーブはできません）
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       （ここからムーブすることはできません）
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       （ムーブが発生するのは、`list[_]`は`T`という、`Copy`トレイトを実装しない型であるためです）
  |                       help: consider borrowing here: `&amp;list[0]`
  |                       （助言：借用するようにしてみてはいかがですか： `&amp;list[0]`）

error[E0507]: cannot move out of a shared reference
（エラー[E0507]：共有の参照からムーブはできません）
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |（データがここでムーブされています）
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         |（ムーブが発生するのは、`item`は`T`という、`Copy`トレイトを実装しない型であるためです）
  |         help: consider removing the `&amp;`: `item`
  |         （助言：`&amp;`を取り除いてみてはいかがですか： `item`）

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>このエラーの鍵となる行は、cannot move out of type [T], a non-copy slice です。
ジェネリックでないバージョンの largest 関数では、最大の i32 か char を探そうとするだけでした。
第 4 章のスタックのみのデータ: コピー節で議論したように、i32 や char のようなサイズが既知の型はスタックに格納できるので、
Copy トレイトを実装しています。
しかし、largest 関数をジェネリックにすると、list 引数が Copy トレイトを実装しない型を含む可能性も出てきたのです。
結果として、list[0]から値を largest にムーブできず、このエラーに陥ったのです。</p>
<p>このコードを Copy トレイトを実装する型だけを使って呼び出すようにしたいなら、
T のトレイト境界に Copy を追加すればよいです！
リスト 10-15 は、関数に渡したスライスの値の型が、
i32 や char などのように PartialOrd と Copy を実装する限りコンパイルできる、
ジェネリックな largest 関数の完全なコードを示しています。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>リスト 10-15: PartialOrd と Copy トレイトを実装するあらゆるジェネリックな型に対して動く、 largest 関数の実際の定義</p>
<p>もし largest 関数を Copy を実装する型だけに制限したくなかったら、
T が Copy ではなく Clone というトレイト境界を持つと指定することもできます。
そうしたら、 largest 関数に所有権が欲しい時にスライスの各値をクローンできます。
clone 関数を使用するということは、
String のようなヒープデータを持つ型の場合により多くのヒープ確保が発生する可能性があることを意味します。
そして、大量のデータを取り扱っていたら、ヒープ確保には時間がかかることもあります。</p>
<p>largest の別の実装方法は、関数がスライスの T 値への参照を返すようにすることです。
戻り値の型を T ではなく&amp;T に変え、それにより関数の本体を参照を返すように変更したら、
Clone や Copy トレイト境界は必要なくなり、ヒープ確保も避けられるでしょう。 これらの代替策をご自身で実装してみましょう！</p>
<h3 id="トレイト境界を使用してメソッド実装を条件分けする"><a class="header" href="#トレイト境界を使用してメソッド実装を条件分けする">トレイト境界を使用して、メソッド実装を条件分けする</a></h3>
<p>ジェネリックな型引数を持つ impl ブロックにトレイト境界を与えることで、 特定のトレイトを実装する型に対するメソッド実装を条件分けできます。例えば、 リスト 10-16 の型 Pair<T>は、常に new 関数を実装します。しかし、Pair<T>は、 内部の型 T が比較を可能にする PartialOrd トレイトと出力を可能にする Display トレイトを実装している時のみ、 cmp_display メソッドを実装します。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
}
</code></pre></pre>
<p>リスト 10-16: トレイト境界によってジェネリックな型に対するメソッド実装を条件分けする</p>
<p>また、別のトレイトを実装するあらゆる型に対するトレイト実装を条件分けすることもできます。 トレイト境界を満たすあらゆる型にトレイトを実装することは、ブランケット実装(blanket implementation)と呼ばれ、 Rust の標準ライブラリで広く使用されています。例を挙げれば、標準ライブラリは、 Display トレイトを実装するあらゆる型に ToString トレイトを実装しています。 標準ライブラリの impl ブロックは以下のような見た目です:</p>
<pre><code>impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>標準ライブラリにはこのブランケット実装があるので、Display トレイトを実装する任意の型に対して、 ToString トレイトで定義された to_string メソッドを呼び出せるのです。 例えば、整数は Display を実装するので、このように整数値を対応する String 値に変換できます:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
let s = 3.to_string();
}
</code></pre></pre>
<p>ブランケット実装は、トレイトのドキュメンテーションの「実装したもの」節に出現します。</p>
<p>トレイトとトレイト境界により、ジェネリックな型引数を使用して重複を減らしつつ、コンパイラに対して、 そのジェネリックな型に特定の振る舞いが欲しいことを指定するコードを書くことができます。 それからコンパイラは、トレイト境界の情報を活用してコードに使用された具体的な型が正しい振る舞いを提供しているか確認できます。 動的型付き言語では、その型に定義されていないメソッドを呼び出せば、実行時 (runtime) にエラーが出るでしょう。 しかし、Rust はこの種のエラーをコンパイル時に移したので、コードが動かせるようになる以前に問題を修正することを強制されるのです。 加えて、コンパイル時に既に確認したので、実行時の振る舞いを確認するコードを書かなくても済みます。 そうすることで、ジェネリクスの柔軟性を諦めることなくパフォーマンスを向上させます。</p>
<p>すでに使っている他のジェネリクスに、ライフタイムと呼ばれるものがあります。 ライフタイムは、型が欲しい振る舞いを保持していることではなく、必要な間だけ参照が有効であることを保証します。 ライフタイムがどうやってそれを行うかを見てみましょう。</p>
<blockquote>
<p>ひとまずトレイトのイメージが今は掴めました。
次はライフタイムです。</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ライフタイムで参照を検証する"><a class="header" href="#ライフタイムで参照を検証する">ライフタイムで参照を検証する</a></h1>
<p>第4章の「参照と借用」節で議論しなかった詳細の一つに、Rustにおいて参照は全てライフタイムを保持するということがあります。 ライフタイムとは、その参照が有効になるスコープのことです。多くの場合、型が推論されるように、 大体の場合、ライフタイムも暗黙的に推論されます。複数の型の可能性があるときには、型を注釈しなければなりません。 同様に、参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈しなければなりません。 コンパイラは、ジェネリックライフタイム引数を使用して関係を注釈し、実行時に実際の参照が確かに有効であることを保証することを要求するのです。</p>
<p>ライフタイムの概念は、他のプログラミング言語の道具とはどこか異なり、間違いなくRustで一番際立った機能になっています。 この章では、ライフタイムの全体を解説することはしませんが、 ライフタイム記法が必要となる最も一般的な場合について議論しますので、ライフタイムの概念について馴染むことができるでしょう。</p>
<h2 id="ライフタイムでダングリング参照を回避する"><a class="header" href="#ライフタイムでダングリング参照を回避する">ライフタイムでダングリング参照を回避する</a></h2>
<p>ライフタイムの主な目的は、ダングリング参照を回避することです。ダングリング参照によりプログラムは、 参照するつもりだったデータ以外のデータを参照してしまいます。リスト10-17のプログラムを考えてください。 これには、外側のスコープと内側のスコープが含まれています。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
}
</code></pre></pre>
<p>リスト10-17: 値がスコープを抜けてしまった参照を使用しようとする</p>
<blockquote>
<p>注釈: リスト10-17や10-18、10-24では、変数に初期値を与えずに宣言しているので、変数名は外側のスコープに存在します。 初見では、これはRustにはnull値が存在しないということと衝突しているように見えるかもしれません。 しかしながら、値を与える前に変数を使用しようとすれば、コンパイルエラーになり、 確かにRustではnull値は許可されていないことがわかります。</p>
</blockquote>
<p>外側のスコープで初期値なしのrという変数を宣言し、内側のスコープで初期値5のxという変数を宣言しています。 内側のスコープ内で、rの値をxへの参照にセットしようとしています。それから内側のスコープが終わり、 rの値を出力しようとしています。rが参照している値が使おうとする前にスコープを抜けるので、 このコードはコンパイルできません。こちらがエラーメッセージです:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
（エラー[E0597]: `x`の生存期間が短すぎます）
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
   |                   (借用された値の生存期間が短すぎます)
8  |         }
   |         - `x` dropped here while still borrowed
   |          (`x`は借用されている間にここでドロップされました)
9  |
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here
   |                            (その後、借用はここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>変数xの「生存期間が短すぎます」。原因は、内側のスコープが7行目で終わった時点でxがスコープを抜けるからです。 ですが、rはまだ、外側のスコープに対して有効です; スコープが大きいので、「長生きする」と言います。 Rustで、このコードが動くことを許可していたら、rはxがスコープを抜けた時に解放されるメモリを参照していることになり、 rで行おうとするいかなることもちゃんと動作しないでしょう。では、どうやってコンパイラはこのコードが無効であると決定しているのでしょうか？ それは、借用チェッカーを使用しているのです。</p>
<h2 id="借用精査機"><a class="header" href="#借用精査機">借用精査機</a></h2>
<p>Rustコンパイラには、スコープを比較して全ての借用が有効であるかを決定する借用チェッカーがあります。 リスト10-18は、リスト10-17と同じコードを示していますが、変数のライフタイムを表示する注釈が付いています。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
}

</code></pre></pre>
<p>リスト10-18: それぞれ'aと'bと名付けられたrとxのライフタイムの注釈</p>
<p>ここで、rのライフタイムは'a、xのライフタイムは'bで注釈しました。ご覧の通り、 内側の'bブロックの方が、外側の'aライフタイムブロックよりはるかに小さいです。 コンパイル時に、コンパイラは2つのライフタイムのサイズを比較し、rは'aのライフタイムだけれども、 'bのライフタイムのメモリを参照していると確認します。'bは'aよりも短いので、プログラムは拒否されます: 参照の対象が参照ほど長生きしないのです。</p>
<p>リスト10-19でコードを修正したので、ダングリング参照はなくなり、エラーなくコンパイルできます。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
}
</code></pre></pre>
<p>リスト10-19: データのライフタイムが参照より長いので、有効な参照</p>
<p>ここでxのライフタイムは'bになり、今回の場合'aよりも大きいです。つまり、 コンパイラはxが有効な間、rの参照も常に有効になることを把握しているので、rはxを参照できます。</p>
<p>今や、参照のライフタイムがどれだけであるかと、コンパイラがライフタイムを解析して参照が常に有効であることを保証する仕組みがわかったので、 関数における引数と戻り値のジェネリックなライフタイムを探究しましょう。</p>
<h2 id="関数のジェネリックなライフタイム"><a class="header" href="#関数のジェネリックなライフタイム">関数のジェネリックなライフタイム</a></h2>
<p>2つの文字列スライスのうち、長い方を返す関数を書きましょう。この関数は、 2つの文字列スライスを引数に取り、1つの文字列スライスを返します。longest関数の実装完了後、 リスト10-20のコードは、The longest string is abcdと出力するはずです。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    // 最長の文字列は、{}です
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre></pre>
<p>リスト10-20: longest関数を呼び出して2つの文字列スライスのうち長い方を探すmain関数</p>
<p>関数に取ってほしい引数が文字列スライス、つまり参照であることに注意してください(&amp;変数名の形)。 何故なら、longest関数に引数の所有権を奪ってほしくないからです。 リスト10-20で使用している引数が、我々が必要としているものである理由についてもっと詳しい議論は、 第4章の「引数としての文字列スライス」節をご参照ください。</p>
<p>リスト10-21に示すようにlongest関数を実装しようとしたら、コンパイルできないでしょう。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-21: 2つの文字列スライスのうち長い方を返すけれども、コンパイルできないlongest関数の実装</p>
<p>代わりに、以下のようなライフタイムに言及するエラーが出ます:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
(エラー[E0106]: ライフタイム指定子が不足しています)
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |                                   (ライフタイム引数があるべきです)
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
  (助言: この関数の戻り値型は借用された値を含んでいますが、
   シグニチャは、それが`x`と`y`どちらから借用されたものなのか宣言していません)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>助言テキストが、戻り値の型はジェネリックなライフタイム引数である必要があると明かしています。 というのも、返している参照がxかyのどちらを参照しているか、コンパイラにはわからないからです。 実際のところ、この関数の本体のifブロックはxへの参照を返し、elseブロックはyへの参照を返すので、 どちらなのか私たちにもわかりません！</p>
<p>この関数を定義する際、この関数に渡される具体的な値がわからないので、ifケースとelseケースのどちらが実行されるかわからないのです。 また、リスト10-18と10-19で、返す参照が常に有効であるかを決定したときのようにスコープを見ることも、渡される参照の具体的なライフタイムがわからないのでできないのです。 借用チェッカーもこれを決定することはできません。xとyのライフタイムがどう戻り値のライフタイムと関係するかわからないからです。 このエラーを修正するために、借用チェッカーが解析を実行できるように、参照間の関係を定義するジェネリックなライフタイム引数を追加しましょう。</p>
<h2 id="ライフタイム注釈記法"><a class="header" href="#ライフタイム注釈記法">ライフタイム注釈記法</a></h2>
<p>ライフタイム注釈は、いかなる参照の生存期間も変えることはありません。シグニチャにジェネリックな型引数を指定された 関数が、あらゆる型を受け取ることができるのと同様に、ジェネリックなライフタイム引数を指定された関数は、 あらゆるライフタイムの参照を受け取ることができます。ライフタイム注釈は、ライフタイムに影響することなく、 複数の参照のライフタイムのお互いの関係を記述します。</p>
<p>ライフタイム注釈は、少し不自然な記法です: ライフタイム引数の名前はアポストロフィー(')で始まらなければならず、 通常全部小文字で、ジェネリック型のようにとても短いです。多くの人は、'aという名前を使います。 ライフタイム引数注釈は、参照の&amp;の後に配置し、注釈と参照の型を区別するために空白を1つ使用します。</p>
<p>例を挙げましょう: ライフタイム引数なしのi32への参照、'aというライフタイム引数付きのi32への参照、 そして同じくライフタイム'aを持つi32への可変参照です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;i32        // a reference
            // (ただの)参照
&amp;'a i32     // a reference with an explicit lifetime
            // 明示的なライフタイム付きの参照
&amp;'a mut i32 // a mutable reference with an explicit lifetime
            // 明示的なライフタイム付きの可変参照
<span class="boring">}
</span></code></pre></pre>
<p>1つのライフタイム注釈それだけでは、大して意味はありません。注釈は、複数の参照のジェネリックなライフタイム引数が、 お互いにどう関係するかをコンパイラに指示することを意図しているからです。例えば、 ライフタイム'a付きのi32への参照となる引数firstのある関数があるとしましょう。 この関数にはさらに、'aのライフタイム付きのi32への別の参照となるsecondという別の引数もあります。 ライフタイム注釈は、firstとsecondの参照がどちらもこのジェネリックなライフタイムと同じだけ生きることを示唆します。</p>
<h2 id="関数シグニチャにおけるライフタイム注釈"><a class="header" href="#関数シグニチャにおけるライフタイム注釈">関数シグニチャにおけるライフタイム注釈</a></h2>
<p>さて、longest関数を例にライフタイム注釈を詳しく見ていきましょう。ジェネリックな型引数同様、 関数名と引数リストの間の山カッコの中にジェネリックなライフタイム引数を宣言します。 このシグニチャで表現したい制約は、引数の全ての参照と戻り値が同じライフタイムを持つことです。 リスト10-22に示すように、ライフタイムを'aと名付け、それを各参照に付与します。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-22: シグニチャの全参照が同じライフタイム'aを持つと指定したlongest関数の定義</p>
<p>このコードはコンパイルでき、リスト10-20のmain関数とともに使用したら、欲しい結果になるはずです。</p>
<p>これで関数シグニチャは、何らかのライフタイム'aに対して、関数は2つの引数を取り、 どちらも少なくともライフタイム'aと同じだけ生きる文字列スライスであるとコンパイラに教えるようになりました。 また、この関数シグニチャは、関数から返る文字列スライスも少なくともライフタイム'aと同じだけ生きると、 コンパイラに教えています。 実際には、longest関数が返す参照のライフタイムは、渡された参照のうち、小さい方のライフタイムと同じであるという事です。 これらの制約は、まさに私たちがコンパイラに保証してほしかったものです。</p>
<p>この関数シグニチャでライフタイム引数を指定する時、渡されたり、返したりした、いかなる値のライフタイムも変更していないことを思い出してください。 むしろ、借用チェッカーは、これらの制約を守らない値全てを拒否するべきと指定しています。 longest関数は、xとyの正確な生存期間を知っている必要はなく、 このシグニチャを満たすようなスコープを'aに代入できることを知っているだけであることに注意してください。</p>
<p>関数にライフタイムを注釈するときは、注釈は関数の本体ではなくシグニチャに付与します。 コンパイラは注釈がなくとも関数内のコードを解析できます。しかしながら、 関数に関数外からの参照や関数外への参照がある場合、コンパイラが引数や戻り値のライフタイムを自力で解決することはほとんど不可能になります。 そのライフタイムは、関数が呼び出される度に異なる可能性があります。このために、手動でライフタイムを注釈する必要があるのです。</p>
<p>具体的な参照をlongestに渡すと、'aに代入される具体的なライフタイムは、xのスコープの一部であってyのスコープと重なる部分となります。 言い換えると、ジェネリックなライフタイム'aは、xとyのライフタイムのうち、小さい方に等しい具体的なライフタイムになるのです。 返却される参照を同じライフタイム引数'aで注釈したので、返却される参照もxかyのライフタイムの小さい方と同じだけ有効になるでしょう。</p>
<p>ライフタイム注釈が異なる具体的なライフタイムを持つ参照を渡すことでlongest関数を制限する方法を見ましょう。 リスト10-23はそのシンプルな例です。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 長い文字列は長い
    let string1 = String::from(&quot;long string is long&quot;);
    // （訳注：この言葉自体に深い意味はない。下の&quot;xyz&quot;より長いということだけが重要）

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        // 一番長い文字列は{}
        println!(&quot;The longest string is {}&quot;, result);
    }
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-23: 異なる具体的なライフタイムを持つString値への参照でlongest関数を使用する</p>
<p>この例において、string1は外側のスコープの終わりまで有効で、string2は内側のスコープの終わりまで有効、 そしてresultは内側のスコープの終わりまで有効な何かを参照しています。このコードを実行すると、 借用チェッカーがこのコードを良しとするのがわかるでしょう。要するに、コンパイルでき、 The longest string is long string is longと出力するのです。</p>
<p>次に、resultの参照のライフタイムが2つの引数の小さい方のライフタイムになることを示す例を試しましょう。 result変数の宣言を内側のスコープの外に移すものの、result変数への代入はstring2のスコープ内に残したままにします。 それからresultを使用するprintln!を内側のスコープの外、内側のスコープが終わった後に移動します。 リスト10-24のコードはコンパイルできません。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-24: string2がスコープを抜けてからresultを使用しようとする</p>
<p>このコードのコンパイルを試みると、こんなエラーになります:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>このエラーは、resultがprintln!文に対して有効であるためには、string2が外側のスコープの終わりまで有効である必要があることを示しています。 関数引数と戻り値のライフタイムを同じライフタイム引数'aで注釈したので、コンパイラはこのことを知っています。</p>
<p>人間からしたら、string1はstring2よりも長く、それ故にresultがstring1への参照を含んでいることは コードから明らかです。まだstring1はスコープを抜けていないので、 string1への参照はprintln!にとって有効でしょう。ですが、コンパイラはこの場合、 参照が有効であると見なせません。longest関数から返ってくる参照のライフタイムは、 渡した参照のうちの小さい方と同じだとコンパイラに指示しました。したがって、 借用チェッカーは、リスト10-24のコードを無効な参照がある可能性があるとして許可しないのです。</p>
<p>試しに、値や、longest関数に渡される参照のライフタイムや、返される参照の使われかたが異なる実験をもっとしてみてください。 コンパイル前に、その実験が借用チェッカーを通るかどうか仮説を立ててください; そして、正しいか確かめてください！</p>
<h2 id="ライフタイムの観点で思考する"><a class="header" href="#ライフタイムの観点で思考する">ライフタイムの観点で思考する</a></h2>
<p>何にライフタイム引数を指定する必要があるかは、関数が行っていることに依存します。例えば、 longest関数の実装を最長の文字列スライスではなく、常に最初の引数を返すように変更したら、 y引数に対してライフタイムを指定する必要はなくなるでしょう。以下のコードはコンパイルできます:</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>この例では、引数xと戻り値に対してライフタイム引数'aを指定しましたが、引数yには指定していません。 yのライフタイムはxや戻り値のライフタイムとは何の関係もないからです。</p>
<p>関数から参照を返す際、戻り値型のライフタイム引数は、引数のうちどれかのライフタイム引数と一致する必要があります。 返される参照が引数のどれかを参照していないならば、この関数内で生成された値を参照しているはずです。 すると、その値は関数の末端でスコープを抜けるので、これはダングリング参照になるでしょう。 以下に示す、コンパイルできないlongest関数の未完成の実装を考えてください:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    // 本当に長い文字列
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre></pre>
<blockquote>
<p>ライフタイム引数が関係ないので、何の意味があるのか？となるます</p>
</blockquote>
<p>ここでは、たとえ、戻り値型にライフタイム引数'aを指定していても、戻り値のライフタイムは、 引数のライフタイムと全く関係がないので、この実装はコンパイルできないでしょう。 こちらが、得られるエラーメッセージです:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
(エラー[E0515]: ローカル変数`result`を参照している値は返せません)
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here
   |    (現在の関数に所有されているデータを参照する値を返しています
   |     `result`はここで借用されています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>問題は、resultがlongest関数の末端でスコープを抜け、片付けられてしまうことです。 かつ、関数からresultへの参照を返そうともしています。ダングリング参照を変えてくれるようなライフタイム引数を指定する手段はなく、 コンパイラは、ダングリング参照を生成させてくれません。今回の場合、最善の修正案は、 （呼び出し先ではなく）呼び出し元の関数に値の片付けをさせるために、参照ではなく所有されたデータ型を返すことでしょう。</p>
<p>究極的にライフタイム記法は、関数のいろんな引数と戻り値のライフタイムを接続することに関するものです。 一旦それらが繋がれば、メモリ安全な処理を許可し、ダングリングポインタを生成したりメモリ安全性を侵害したりする処理を禁止するのに十分な情報をコンパイラは得たことになります。</p>
<h2 id="構造体定義のライフタイム注釈"><a class="header" href="#構造体定義のライフタイム注釈">構造体定義のライフタイム注釈</a></h2>
<p>ここまで、所有された型を保持する構造体だけを定義してきました。構造体に参照を保持させることもできますが、 その場合、構造体定義の全参照にライフタイム注釈を付け加える必要があるでしょう。 リスト10-25には、文字列スライスを保持するImportantExcerpt(重要な一節)という構造体があります。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    // 僕をイシュマエルとお呼び。何年か前・・・
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    //                                                  &quot;'.'が見つかりませんでした&quot;
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p>リスト10-25: 参照を含む構造体なので、定義にライフタイム注釈が必要</p>
<p>この構造体には文字列スライスを保持する1つのフィールド、partがあり、これは参照です。 ジェネリックなデータ型同様、構造体名の後、山カッコの中にジェネリックなライフタイム引数の名前を宣言するので、 構造体定義の本体でライフタイム引数を使用できます。この注釈は、ImportantExcerptのインスタンスが、 partフィールドに保持している参照よりも長生きしないことを意味します。</p>
<p>ここのmain関数は、変数novelに所有されるStringの、最初の文への参照を保持するImportantExcerptインスタンスを生成しています。 novelのデータは、ImportantExcerptインスタンスが作られる前に存在しています。 加えて、ImportantExcerptがスコープを抜けるまでnovelはスコープを抜けないので、 ImportantExcerptインスタンスの参照は有効なのです。</p>
<h2 id="ライフタイム省略"><a class="header" href="#ライフタイム省略">ライフタイム省略</a></h2>
<p>全参照にはライフタイムがあり、参照を使用する関数や構造体にはライフタイム引数を指定する必要があることを学びました。 しかし、リスト4-9にあった関数（リスト10-26に再度示しました）はライフタイム注釈なしでコンパイルできました。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word works on slices of `String`s
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word works on slices of string literals
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<p>リスト10-26: リスト4-9で定義した、引数と戻り値型が参照であるにも関わらず、ライフタイム注釈なしでコンパイルできた関数</p>
<p>この関数がライフタイム注釈なしでコンパイルできる理由には、Rustの歴史が関わっています: 昔のバージョンのRust(1.0以前)では、 全参照に明示的なライフタイムが必要だったので、このコードはコンパイルできませんでした。 その頃、関数シグニチャはこのように記述されていたのです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
<span class="boring">}
</span></code></pre></pre>
<p>多くのRustコードを書いた後、Rustチームは、Rustプログラマが、 特定の場面で何度も同じライフタイム注釈を入力していることを発見しました。これらの場面は予測可能で、 いくつかの決まりきったパターンに従っていました。開発者はこのパターンをコンパイラのコードに落とし込んだので、 このような場面には借用チェッカーがライフタイムを推論できるようになり、明示的な注釈を必要としなくなったのです。</p>
<p>ここで、このRustの歴史話が関係しているのは、他にも決まりきったパターンが出現し、コンパイラに追加されることもあり得るからです。 将来的に、さらに少数のライフタイム注釈しか必要にならない可能性もあります。</p>
<p>コンパイラの参照解析に落とし込まれたパターンは、ライフタイム省略規則と呼ばれます。 これらはプログラマが従う規則ではありません; コンパイラが考慮する一連の特定のケースであり、 自分のコードがこのケースに当てはまれば、ライフタイムを明示的に書く必要はなくなります。</p>
<p>省略規則は、完全な推論を提供しません。コンパイラが決定的に規則を適用できるけれども、 参照が保持するライフタイムに関してそれでも曖昧性があるなら、コンパイラは、残りの参照がなるべきライフタイムを推測しません。 この場合コンパイラは、それらを推測するのではなくエラーを与えます。 これらは、参照がお互いにどう関係するかを指定するライフタイム注釈を追記することで解決できます。</p>
<p>関数やメソッドの引数のライフタイムは、入力ライフタイムと呼ばれ、 戻り値のライフタイムは出力ライフタイムと称されます。</p>
<p>コンパイラは3つの規則を活用し、明示的な注釈がない時に、参照がどんなライフタイムになるかを計算します。 最初の規則は入力ライフタイムに適用され、2番目と3番目の規則は出力ライフタイムに適用されます。 コンパイラが3つの規則の最後まで到達し、それでもライフタイムを割り出せない参照があったら、 コンパイラはエラーで停止します。 これらのルールはfnの定義にもimplブロックにも適用されます。</p>
<p>最初の規則は、参照である各引数は、独自のライフタイム引数を得るというものです。換言すれば、 1引数の関数は、1つのライフタイム引数を得るということです: fn foo&lt;'a&gt;(x: &amp;'a i32); 2つ引数のある関数は、2つの個別のライフタイム引数を得ます: fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32); 以下同様。</p>
<p>2番目の規則は、1つだけ入力ライフタイム引数があるなら、そのライフタイムが全ての出力ライフタイム引数に代入されるというものです: fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32。</p>
<p>3番目の規則は、複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが&amp;selfや&amp;mut selfだったら、 selfのライフタイムが全出力ライフタイム引数に代入されるというものです。 この3番目の規則により、必要なシンボルの数が減るので、メソッドが遥かに読み書きしやすくなります。</p>
<p>コンパイラの立場になってみましょう。これらの規則を適用して、リスト10-26のfirst_word関数のシグニチャの参照のライフタイムが何か計算します。 シグニチャは、参照に紐づけられるライフタイムがない状態から始まります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>そうして、コンパイラは最初の規則を適用し、各引数が独自のライフタイムを得ると指定します。 それを通常通り'aと呼ぶので、シグニチャはこうなります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>1つだけ入力ライフタイムがあるので、2番目の規則を適用します。2番目の規則は、1つの入力引数のライフタイムが、 出力引数に代入されると指定するので、シグニチャはこうなります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
<span class="boring">}
</span></code></pre></pre>
<p>もうこの関数シグニチャの全ての参照にライフタイムが付いたので、コンパイラは、 プログラマにこの関数シグニチャのライフタイムを注釈してもらう必要なく、解析を続行できます。</p>
<p>別の例に目を向けましょう。今回は、リスト10-21で取り掛かったときにはライフタイム引数がなかったlongest関数です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>最初の規則を適用しましょう: 各引数が独自のライフタイムを得るのです。今回は、 1つではなく2つ引数があるので、ライフタイムも2つです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>2つ以上入力ライフタイムがあるので、2番目の規則は適用されないとわかります。また3番目の規則も適用されません。 longestはメソッドではなく関数なので、どの引数もselfではないのです。3つの規則全部を適用した後でも、 まだ戻り値型のライフタイムが判明していません。このために、リスト10-21でこのコードをコンパイルしようとしてエラーになったのです: コンパイラは、ライフタイム省略規則全てを適用したけれども、シグニチャの参照全部のライフタイムを計算できなかったのです。</p>
<p>実際のところ、3番目の規則はメソッドのシグニチャにしか適用されません。ですので、次はその文脈においてライフタイムを観察し、 3番目の規則のおかげで、メソッドシグニチャであまり頻繁にライフタイムを注釈しなくても済む理由を確認します。</p>
<h2 id="メソッド定義におけるライフタイム注釈"><a class="header" href="#メソッド定義におけるライフタイム注釈">メソッド定義におけるライフタイム注釈</a></h2>
<p>構造体にライフタイムのあるメソッドを実装する際、リスト10-11で示したジェネリックな型引数と同じ記法を使用します。 ライフタイム引数を宣言し使用する場所は、構造体フィールドかメソッド引数と戻り値に関係するかによります。</p>
<p>構造体のフィールド用のライフタイム名は、implキーワードの後に宣言する必要があり、 それから構造体名の後に使用されます。そのようなライフタイムは構造体の型の一部になるからです。</p>
<p>implブロック内のメソッドシグニチャでは、参照は構造体のフィールドの参照のライフタイムに紐づいている可能性と、 独立している可能性があります。加えて、ライフタイム省略規則により、メソッドシグニチャでライフタイム注釈が必要なくなることがよくあります。 リスト10-25で定義したImportantExcerptという構造体を使用した例をいくつか見てみましょう。</p>
<p>まず、唯一の引数がselfへの参照で戻り値がi32という何かへの参照ではないlevelというメソッドを使用します:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">       //       &quot;お知らせします: {}&quot;
</span><span class="boring">       println!(&quot;Attention please: {}&quot;, announcement);
</span><span class="boring">       self.part
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">   let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">   let i = ImportantExcerpt {
</span><span class="boring">       part: first_sentence,
</span><span class="boring">   };
</span><span class="boring">}
</span></code></pre></pre>
<p>impl後のライフタイム引数宣言と型名の後にそれを使用するのは必須ですが、最初の省略規則のため、 selfへの参照のライフタイムを注釈する必要はありません。</p>
<p>3番目のライフタイム省略規則が適用される例はこちらです:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   fn level(&amp;self) -&gt; i32 {
</span><span class="boring">       3
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        //       &quot;お知らせします: {}&quot;
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">   let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">   let i = ImportantExcerpt {
</span><span class="boring">       part: first_sentence,
</span><span class="boring">   };
</span><span class="boring">}
</span></code></pre></pre>
<p>2つ入力ライフタイムがあるので、コンパイラは最初のライフタイム省略規則を適用し、 &amp;selfとannouncementに独自のライフタイムを与えます。それから、 引数の1つが&amp;selfなので、戻り値型は&amp;selfのライフタイムを得て、 全てのライフタイムが説明されました。</p>
<h2 id="静的ライフタイム"><a class="header" href="#静的ライフタイム">静的ライフタイム</a></h2>
<p>議論する必要のある1種の特殊なライフタイムが、'staticであり、これは、この参照がプログラムの全期間生存できる事を意味します。 文字列リテラルは全て'staticライフタイムになり、次のように注釈できます:</p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
// 僕は静的ライフタイムを持ってるよ
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
}
</code></pre></pre>
<p>この文字列のテキストは、プログラムのバイナリに直接格納され、常に利用可能です。故に、全文字列リテラルのライフタイムは、 'staticなのです。</p>
<p>エラーメッセージで、'staticライフタイムを使用するよう勧める提言を見かける可能性があります。 ですが、参照に対してライフタイムとして'staticを指定する前に、今ある参照が本当にプログラムの全期間生きるかどうか考えてください。 それが可能であったとしても、参照がそれだけの期間生きてほしいのかどうか考慮するのも良いでしょう。 ほとんどの場合、問題は、ダングリング参照を生成しようとしているか、利用可能なライフタイムの不一致が原因です。 そのような場合、解決策はその問題を修正することであり、'staticライフタイムを指定することではありません。</p>
<h1 id="ジェネリックな型引数トレイト境界ライフタイムを一度に"><a class="header" href="#ジェネリックな型引数トレイト境界ライフタイムを一度に">ジェネリックな型引数、トレイト境界、ライフタイムを一度に</a></h1>
<p>ジェネリックな型引数、トレイト境界、ライフタイム指定の構文のすべてを1つの関数で簡単に見てみましょう！</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        &quot;Today is someone's birthday!&quot;,
    );
    println!(&quot;The longest string is {}&quot;, result);
}

use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    //       &quot;アナウンス！ {}&quot;
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>これがリスト10-22からの2つの文字列のうち長い方を返すlongest関数ですが、 ジェネリックな型Tのannという追加の引数があり、これはwhere節で指定されているように、 Displayトレイトを実装するあらゆる型で埋めることができます。 この追加の引数は、関数が文字列スライスの長さを比較する前に出力されるので、 Displayトレイト境界が必要なのです。ライフタイムは一種のジェネリックなので、 ライフタイム引数'aとジェネリックな型引数Tが関数名の後、山カッコ内の同じリストに収まっています。</p>
<h1 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h1>
<p>たくさんのことをこの章では講義しましたね！今やジェネリックな型引数、トレイトとトレイト境界、そしてジェネリックなライフタイム引数を知ったので、 多くの異なる場面で動くコードを繰り返すことなく書く準備ができました。ジェネリックな型引数により、 コードを異なる型に適用させてくれます。トレイトとトレイト境界は、型がジェネリックであっても、 コードが必要とする振る舞いを持つことを保証します。ライフタイム注釈を活用して、 この柔軟なコードにダングリング参照が存在しないことを保証する方法を学びました。 さらにこの解析は全てコンパイル時に起こり、実行時のパフォーマンスには影響しません！</p>
<p>信じられないかもしれませんが、この章で議論した話題にはもっともっと学ぶべきことがあります: 第17章ではトレイトオブジェクトを議論します。これはトレイトを使用する別の手段です。 非常に高度な筋書きの場合でのみ必要になる、ライフタイム注釈が関わる、もっと複雑な筋書きもあります。 それらについては、Rust Referenceをお読みください。 ですが次は、コードがあるべき通りに動いていることを確かめられるように、Rustでテストを書く方法を学びます。</p>
<blockquote>
<p>ライフタイムはダングリング参照を防ぐため、そういったエラーを無くすためというところからスタートする。</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="自動テストを書く"><a class="header" href="#自動テストを書く">自動テストを書く</a></h1>
<p>1972年のエッセイ「謙虚なプログラマ」でエドガー・W・ダイクストラは以下のように述べています。 「プログラムのテストは、バグの存在を示すには非常に効率的な手法であるが、 バグの不在を示すには望み薄く不適切である」と。これは、できるだけテストを試みるべきではないということではありません。</p>
<p>プログラムの正当性は、どこまで自分のコードが意図していることをしているかなのです。 Rustは、プログラムの正当性に重きを置いて設計されていますが、 正当性は複雑で、単純に証明することはありません。Rustの型システムは、 この重荷の多くの部分を肩代わりしてくれますが、型システムはあらゆる種類の不当性を捕捉してはくれません。 ゆえに、Rustでは、言語内で自動化されたソフトウェアテストを書くことをサポートしているのです。</p>
<p>例として、渡された何かの数値に2を足すadd_twoという関数を書くとしましょう。 この関数のシグニチャは、引数に整数を取り、結果として整数を返します。 この関数を実装してコンパイルすると、コンパイラはこれまでに学んできた型チェックと借用チェックを全て行い、 例えば、Stringの値や無効な参照をこの関数に渡していないかなどを確かめるのです。 ところが、コンパイラはプログラマがまさしく意図したことを関数が実行しているかどうかは確かめられません。 つまり、そうですね、引数に10を足したり、50を引いたりするのではなく、引数に2を足していることです。 そんな時に、テストは必要になるのです。</p>
<p>例えば、add_two関数に3を渡した時に、戻り値は5であることをアサーションするようなテストを書くことができます。 コードに変更を加えた際にこれらのテストを走らせ、既存の正当な振る舞いが変わっていないことを確認できます。</p>
<p>テストは、複雑なスキルです: いいテストの書き方をあらゆる方面から講義することは1章だけではできないのですが、 Rustのテスト機構のメカニズムについて議論します。テストを書く際に利用可能になるアノテーションとマクロについて、 テストを実行するのに提供されているオプションと標準の動作、さらにテストをユニットテストや統合テストに体系化する方法について語ります。</p>
<blockquote>
<p>テストは自分の想定したことをテストできるかをどのように表現することが大事であって、想定できないことはテストできません。（想定できるミスは防ぎましょうという意味合いが強いです。想定できないものはテストすらできないので）
テスト駆動開発系のエンジニアは非常に攻撃的な方も多いので注意することが不可欠です。自分のペースでかつ確実に実力をつけていきましょう。</p>
<p>テストコードの記述には必ず考慮漏れが発生し、その考慮漏れを見つけて「オメェ馬鹿じゃねーの？」というマウントをとってくる人がいますが、プロジェクト全体から見て、採用できる人数に限りがあり、なおかつオープンの場所で叱責はチームの指揮を下げます。またチームの雰囲気がだれている時にスポーツでは引き締めの言葉などを伝えて、緊張感を持たせる手法もありますが、システム開発は長期戦です、基本的にハイパフォーマンスの集中力は続きません。となると戦略的には楽しく作業することが一番いい手法になります。長距離スポーツのマラソンでも長くても3時間ですが、チーム開発は6ヶ月
や1年かかります。それ以上もかかります。なので重要なのは離脱せず、長く続くチーム力が求められます。</p>
<p>能力が低いことを指摘することを正当化する人もいますが、その方は優秀なのに、なぜGoogleやMicrosoftに行かないのですか？と逆に聞きたくなります。</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="テストの記述法"><a class="header" href="#テストの記述法">テストの記述法</a></h1>
<p>テストは、テスト以外のコードが想定された方法で機能していることを実証するRustの関数です。 テスト関数の本体は、典型的には以下の3つの動作を行います:</p>
<ol>
<li>必要なデータや状態をセットアップする。</li>
<li>テスト対象のコードを走らせる。</li>
<li>結果が想定通りであることを断定（以下、アサーションという）する。</li>
</ol>
<p>Rustが、特にこれらの動作を行うテストを書くために用意している機能を見ていきましょう。 これには、test属性、いくつかのマクロ、should_panic属性が含まれます。</p>
<h2 id="テスト関数の構成"><a class="header" href="#テスト関数の構成">テスト関数の構成</a></h2>
<p>最も単純には、Rustにおけるテストはtest属性で注釈された関数のことです。属性とは、 Rustコードの部品に関するメタデータです; 一例を挙げれば、構造体とともに第5章で使用したderive属性です。 関数をテスト関数に変えるには、fnの前に#[test]を付け加えてください。 cargo testコマンドでテストを実行したら、コンパイラはtest属性で注釈された関数を走らせるテスト用バイナリをビルドし、 各テスト関数が通過したか失敗したかを報告します。</p>
<blockquote>
<p>fnの前に#[test]をつける</p>
<p>cargo testでテストを実行する</p>
</blockquote>
<p>新しいライブラリプロジェクトをCargoで作ると、テスト関数付きのテストモジュールが自動的に生成されます。 このモジュールのおかげで、新しいプロジェクトを始めるたびにテスト関数の正しい構造とか文法をいちいち検索しなくてすみます。 ここに好きな数だけテスト関数やテストモジュールを追加すればいいというわけです！</p>
<blockquote>
<p>新規作成のでは意識しなくていい</p>
</blockquote>
<p>まず、実際にはコードをテストしない、自動生成されたテンプレートのテストで実験して、テストの動作の性質をいくらか学びましょう。 その後で、以前書いたコードを呼び出し、振る舞いが正しいことをアサーションする、ホンモノのテストを書きましょう。</p>
<p>adderという新しいライブラリプロジェクトを生成しましょう:</p>
<pre><code>$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>adderライブラリのsrc/lib.rsファイルの中身は、リスト11-1のような見た目のはずです。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>リスト11-1: cargo newで自動生成されたテストモジュールと関数</p>
<p>とりあえず、最初の2行は無視し、関数に集中してその動作法を見ましょう。 fn行の#[test]注釈に注目してください: この属性は、これがテスト関数であることを示すので、 テスト実行機はこの関数をテストとして扱うとわかるのです。さらに、testsモジュール内にはテスト関数以外の関数を入れ、 一般的なシナリオをセットアップしたり、共通の処理を行う手助けをしたりもできるので、 #[test]属性でどの関数がテストかを示す必要があるのです。</p>
<p>関数本体は、assert_eq!マクロを使用して、2 + 2が4に等しいことをアサーションしています。 このアサーションは、典型的なテストのフォーマット例をなしているわけです。走らせてこのテストが通る（訳注：テストが成功する、の意味。英語でpassということから、このように表現される）ことを確かめましょう。</p>
<blockquote>
<p>要するにこのテストでは２＋２は４ですか？というテストをしています。
この感覚ですが、僕も最初は「は？」という感覚がありましたが、これは我々が小学生の時から計算を日頃から実施しているので当然のごとくかと思います。
重要なのはA＝Bの式が成り立つのか？そういった観点がテストとして重要です。
もう一度言いますA=Bの条件が成り立つのか？テストはこのAとBの項目を作り出すのがややこしくなるので複雑になります。
別々のアプローチで導き出された項目が両者あっているからテストに合格するという流れの認識です。これがないと結構苦労しました。（てか僕が苦労しました。）</p>
</blockquote>
<p>cargo testコマンドでプロジェクトにあるテストが全て実行されます。リスト11-2に示したようにですね。</p>
<pre><code>adder$ cargo test
   Compiling adder v0.1.0 (/Users/matsumotokazumasa/poc/rust/rust-programing/adder)
    Finished test [unoptimized + debuginfo] target(s) in 2.22s
     Running unittests src/lib.rs (target/debug/deps/adder-d053b13dba04ef5b)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

adder$
</code></pre>
<p>リスト11-2: 自動生成されたテストを走らせた出力</p>
<p>Cargoがテストをコンパイルし、走らせました。Compiling, Finished, Runningの行の後にrunning 1 testの行があります。 次行が、生成されたテスト関数のit_worksという名前とこのテストの実行結果、okを示しています。 テスト実行の総合的なまとめが次に出現します。test result:ok.というテキストは、 全テストが通ったことを意味し、1 passed; 0 failedと読める部分は、通過または失敗したテストの数を合計しているのです。</p>
<blockquote>
<p>順番は</p>
<p>・Compiling（コンパイル）</p>
<p>・Finished（コンパイル完了）</p>
<p>・Running（実行中）</p>
<p>・動作確認結果</p>
<p>・実行結果</p>
<p>・テスト結果のまとめ</p>
<p>・テスト数とテストが通った数と失敗した数の表示</p>
<p>という順番に表示されます。</p>
</blockquote>
<p>無視すると指定したテストは何もなかったため、まとめは0 ignoredと示しています。 また、実行するテストにフィルタをかけもしなかったので、まとめの最後に0 filtered outと表示されています。 テストを無視することとフィルタすることに関しては次の節、テストの実行され方を制御するで語ります。</p>
<blockquote>
<p>テストは「無視すること」と「フィルタリングすること」ができる</p>
</blockquote>
<p>0 measuredという統計は、パフォーマンスを測定するベンチマークテスト用です。 ベンチマークテストは、本書記述の時点では、nightly版のRustでのみ利用可能です。 詳しくは、ベンチマークテストのドキュメンテーションを参照されたし。</p>
<p><a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">ベンチマークテストとは？</a></p>
<p>テスト出力の次の部分、つまりDoc-tests adderで始まる部分は、ドキュメンテーションテストの結果用のものです。 まだドキュメンテーションテストは何もないものの、コンパイラは、APIドキュメントに現れるどんなコード例もコンパイルできます。 この機能により、ドキュメントとコードを同期することができるわけです。ドキュメンテーションテストの書き方については、 第14章のテストとしてのドキュメンテーションコメント節で議論しましょう。今は、Doc-tests出力は無視します。</p>
<p>テストの名前を変更してどうテスト出力が変わるか確かめましょう。it_works関数を違う名前、explorationなどに変えてください。 そう、以下のように:</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}

fn main() {}
</code></pre></pre>
<p>そして、cargo testを再度走らせます。これで出力がit_worksの代わりにexplorationと表示しています:</p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<blockquote>
<p>テストの関数の名前を変えるとテストの出力の表示も少し変わっていきます。</p>
</blockquote>
<p>別のテストを追加しますが、今回は失敗するテストにしましょう！テスト関数内の何かがパニックすると、 テストは失敗します。各テストは、新規スレッドで実行され、メインスレッドが、テストスレッドが死んだと確認した時、 テストは失敗と印づけられます。第9章でパニックを引き起こす最も単純な方法について語りました。 そう、panic!マクロを呼び出すことですね。src/lib.rsファイルがリスト11-3のような見た目になるよう、 新しいテストanotherを入力してください。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        //このテストを失敗させる
        panic!(&quot;Make this test fail&quot;);
    }
}

fn main() {}
</code></pre></pre>
<p>リスト11-3: panic!マクロを呼び出したために失敗する2番目のテストを追加する</p>
<blockquote>
<p>このテストは必ず失敗します。</p>
</blockquote>
<p>cargo testで再度テストを走らせてください。出力はリスト11-4のようになるはずであり、 explorationテストは通り、anotherは失敗したと表示されます。</p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>リスト11-4: 一つのテストが通り、一つが失敗するときのテスト結果</p>
<p>okの代わりにtest test::anotherの行は、FAILEDを表示しています。個々の結果とまとめの間に、 2つ新たな区域ができました: 最初の区域は、失敗したテスト各々の具体的な理由を表示しています。 今回の場合、anotherは'Make this test fail'でパニックしたために失敗し、 これは、src/lib.rsファイルの10行で起きました。次の区域は失敗したテストの名前だけを列挙しています。 これは、テストがたくさんあり、失敗したテストの詳細がたくさん表示されるときに有用になります。 失敗したテストの名前を使用してそのテストだけを実行し、より簡単にデバッグすることができます。 テストの実行方法については、テストの実行され方を制御する節でもっと語りましょう。</p>
<p>サマリー行が最後に出力されています: 総合的に言うと、テスト結果はFAILEDでした。 一つのテストが通り、一つが失敗したわけです。</p>
<p>様々な状況でのテスト結果がどんな風になるか見てきたので、テストを行う際に有用になるpanic!以外のマクロに目を向けましょう。</p>
<h2 id="assertマクロで結果を確認する"><a class="header" href="#assertマクロで結果を確認する">assert!マクロで結果を確認する</a></h2>
<p>assert!マクロは、標準ライブラリで提供されていますが、テスト内の何らかの条件がtrueと評価されることを確かめたいときに有効です。
assert!マクロには、論理値に評価される引数を与えます。その値がtrueなら、 assert!は何もせず、テストは通ります。
その値がfalseなら、assert!マクロはpanic!マクロを呼び出し、 テストは失敗します。
assert!マクロを使用することで、コードが意図した通りに機能していることを確認する助けになるわけです。</p>
<p>第5章のリスト5-15で、Rectangle構造体とcan_holdメソッドを使用しました。
リスト11-5でもそれを繰り返しています。
このコードをsrc/lib.rsファイルに放り込み、assert!マクロでそれ用のテストを何か書いてみましょう。</p>
<blockquote>
<p>trueやfalseでテストを評価する</p>
<p>なので論理値が返ってくるような関数の実行のテストに有用です。</p>
</blockquote>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {}
</code></pre></pre>
<p>リスト11-5: 第5章からRectangle構造体とそのcan_holdメソッドを使用する</p>
<blockquote>
<p>このメソッドは2つの長方形があり、横と縦の長さがどちらも大きいみたいな感じのイメージになります。</p>
</blockquote>
<p><img src="auto_tests/../imgs/auto_tests/rectangle.png" alt="メソッド" /></p>
<p>can_holdメソッドは論理値を返すので、assert!マクロの完璧なユースケースになるわけです。 リスト11-6で、幅が8、高さが7のRectangleインスタンスを生成し、これが幅5、 高さ1の別のRectangleインスタンスを保持できるとアサーションすることでcan_holdを用いるテストを書きます。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}

fn main() {}
</code></pre></pre>
<p>リスト11-6: より大きな長方形がより小さな長方形を確かに保持できるかを確認するcan_hold用のテスト</p>
<p>testsモジュール内に新しい行を加えたことに注目してください: use super::*です。 testsモジュールは、第7章のモジュールツリーの要素を示すためのパス節で講義した通常の公開ルールに従う普通のモジュールです。 testsモジュールは、内部モジュールなので、外部モジュール内のテスト配下にあるコードを内部モジュールのスコープに持っていく必要があります。 ここではglobを使用して、外部モジュールで定義したもの全てがこのtestsモジュールでも使用可能になるようにしています。</p>
<p>テストはlarger_can_hold_smallerと名付け、必要なRectangleインスタンスを2つ生成しています。 そして、assert!マクロを呼び出し、larger.can_hold(&amp;smaller)の呼び出し結果を渡しました。 この式は、trueを返すと考えられるので、テストは通るはずです。確かめましょう！</p>
<pre><code>$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>通ります！別のテストを追加しましょう。今回は、小さい長方形は、より大きな長方形を保持できないことをアサーションします。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}

fn main() {}
</code></pre></pre>
<p>今回の場合、can_hold関数の正しい結果はfalseなので、その結果をassert!マクロに渡す前に反転させる必要があります。 結果として、can_holdがfalseを返せば、テストは通ります。</p>
<blockquote>
<p>結果を反転させたい時は「!」を設定する必要があるassert(!smaller.can_hold(&amp;larger))みたいな感じです。</p>
</blockquote>
<pre><code>$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>通るテストが2つ！さて、コードにバグを導入したらテスト結果がどうなるか確認してみましょう。 幅を比較する大なり記号を小なり記号で置き換えてcan_holdメソッドの実装を変更しましょう:</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// ここの記号を変更させる
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}

fn main() {}
</code></pre></pre>
<p>テストを実行すると、以下のような出力をします</p>
<pre><code>$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
(スレッド'main'はsrc/lib.rs:28:9の'assertion failed: larger.can_hold(&amp;smaller)'でパニックしました)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>テストによりバグが捕捉されました！larger.widthが8、smaller.widthが5なので、 can_hold内の幅の比較が今はfalseを返すようになったのです: 8は5より小さくないですからね。</p>
<h2 id="assert_eqとassert_neマクロで等値性をテストする"><a class="header" href="#assert_eqとassert_neマクロで等値性をテストする">assert_eq!とassert_ne!マクロで等値性をテストする</a></h2>
<p>機能をテストする一般的な方法は、テスト下にあるコードの結果をコードが返すと期待される値と比較して、 等しいと確かめることです。これをassertマクロを使用して==演算子を使用した式を渡すことで行うこともできます。 しかしながら、これはありふれたテストなので、標準ライブラリには1組のマクロ(assert_eq!とassert_ne!)が提供され、 このテストをより便利に行うことができます。これらのマクロはそれぞれ、二つの引数を比べ、等しいかと等しくないかを確かめます。 また、アサーションが失敗したら二つの値の出力もし、テストが失敗した原因を確認しやすくなります。 一方でassert!マクロは、==式の値がfalseになったことしか示さず、falseになった原因の値は出力しません。</p>
<p>リスト11-7において、引数に2を加えて結果を返すadd_twoという名前の関数を書いています。 そして、assert_eq!マクロでこの関数をテストしています。</p>
<blockquote>
<p>返り値が数値や文字列スライスを返すような関数では等値性（値が一緒かどうか？）をテストする</p>
</blockquote>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}

fn main() {}
</code></pre></pre>
<p>リスト11-7: assert_eq!マクロでadd_two関数をテストする</p>
<blockquote>
<p>これだと、左がテストの答えの結果、右が関数の結果です。これは左と右をどちらでも同じです。</p>
</blockquote>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>assert_eq!マクロに与えた第1引数の4は、add_two(2)の呼び出し結果と等しいです。 このテストの行はtest tests::it_adds_two ... okであり、okというテキストはテストが通ったことを示しています！</p>
<p>コードにバグを仕込んで、assert_eq!を使ったテストが失敗した時にどんな見た目になるのか確認してみましょう。 add_two関数の実装を代わりに3を足すように変えてください:</p>
<p>This code does not produce the desired behavior.</p>
<pre><pre class="playground"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}

fn main() {}
</code></pre></pre>
<p>テストを再度実行します:</p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>テストがバグを捕捉しました！it_adds_twoのテストは失敗し、assertion failed: <code>(left == right)</code>というメッセージを表示し、 leftは4で、rightは5だったと示しています。このメッセージは有用で、デバッグを開始する助けになります: assert_eq!のleft引数は4だったが、add_two(2)があるright引数は5だったことを意味しています。</p>
<p>二つの値が等しいとアサーションを行う関数の引数を expectedとactualと呼び、引数を指定する順序が問題になる言語やテストフレームワークもあることに注意してください。 ですがRustでは、leftとrightと呼ばれ、期待する値とテスト下のコードが生成する値を指定する順序は 問題になりません。今回のテストのアサーションをassert_eq!(add_two(2), 4)と書くこともでき、 そうすると失敗メッセージは、assertion failed: <code>(left == right)</code>となり、 leftが5でrightが4と表示されるでしょう。</p>
<p>assert_ne!マクロは、与えた2つの値が等しくなければ通り、等しければ失敗します。 このマクロは、値が何になるだろうか確信が持てないけれども、コードが意図した通りに動いていれば、 確実にこの値にはならないだろうとわかっているような場合に最も有用になります。例えば、 入力を何らかの手段で変え（て出力す）ることが保証されているけれども、入力の変え方がテストを実行する曜日に依存する関数をテストしているなら、 アサーションすべき最善の事柄は、関数の出力が入力と等しくないことかもしれません。</p>
<p>内部的には、assert_eq!とassert_ne!マクロは、それぞれ==と!=演算子を使用しています。 アサーションが失敗すると、これらのマクロは引数をデバッグフォーマットを使用してプリントするので、 比較対象の値はPartialEqとDebugトレイトを実装していなければなりません。 すべての組み込み型と、ほぼすべての標準ライブラリの型はこれらのトレイトを実装しています。 自分で定義した構造体やenumについては、 その型の値が等しいか等しくないかをアサーションするために、PartialEqを実装する必要があるでしょう。 それが失敗した時にその値をプリントできるように、Debugを実装する必要もあるでしょう。 第5章のリスト5-12で触れたように、どちらのトレイトも導出可能なトレイトなので、 これは通常、単純に構造体やenum定義に#[derive(PartialEq, Debug)]という注釈を追加するだけですみます。 これらやその他の導出可能なトレイトに関する詳細については、付録C、導出可能なトレイトをご覧ください。</p>
<h2 id="カスタムの失敗メッセージを追加する"><a class="header" href="#カスタムの失敗メッセージを追加する">カスタムの失敗メッセージを追加する</a></h2>
<p>さらに、assert!、assert_eq!、assert_ne!の追加引数として、失敗メッセージと共にカスタムのメッセージが表示されるよう、 追加することもできます。assert!の1つの必須引数の後に、 あるいはassert_eq!とassert_ne!の2つの必須引数の後に指定された引数はすべてformat!マクロに渡されるので、 （format!マクロについては第8章の+演算子、またはformat!マクロで連結節で議論しました）、 {}プレースホルダーを含むフォーマット文字列とこのプレースホルダーに置き換えられる値を渡すことができます。 カスタムメッセージは、アサーションがどんな意味を持つかドキュメント化するのに役に立ちます; もしテストが失敗した時、コードにどんな問題があるのかをよりしっかり把握できるはずです。</p>
<blockquote>
<p>エラーメッセージを追加できると「わかりにくさ」から「わかりやすさ」が表現されます</p>
<p>例えば日本語のエラーメッセージは表現がしやすいです。</p>
</blockquote>
<p>例として、人々に名前で挨拶をする関数があり、関数に渡した名前が出力に出現することをテストしたいとしましょう:</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}

fn main() {}
</code></pre></pre>
<p>このプログラムの要件はまだ取り決められておらず、挨拶の先頭のHelloというテキストはおそらく変わります。 要件が変わった時にテストを更新しなくてもよいようにしたいと考え、 greeting関数から返る値と正確な等値性を確認するのではなく、出力が入力引数のテキストを含むことをアサーションするだけにします。</p>
<p>greetingがnameを含まないように変更してこのコードにバグを仕込み、このテストの失敗がどんな風になるのか確かめましょう:</p>
<pre><pre class="playground"><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}

fn main() {}
</code></pre></pre>
<p>このテストを実行すると、以下のように出力されます:</p>
<pre><code>$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>この結果は、アサーションが失敗し、どの行にアサーションがあるかを示しているだけです。 今回の場合、失敗メッセージがgreeting関数から得た値を出力していればより有用でしょう。 テスト関数を変更し、 greeting関数から得た実際の値で埋められるプレースホルダーを含むフォーマット文字列からなるカスタムの失敗メッセージを与えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            //挨拶(greeting)は名前を含んでいません。その値は`{}`でした
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>これでテストを実行したら、より有益なエラーメッセージが得られるでしょう:</p>
<pre><code>$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>実際に得られた値がテスト出力に表示されているので、起こると想定していたものではなく、 起こったものをデバッグするのに役に立ちます。</p>
<h2 id="should_panicでパニックを確認する"><a class="header" href="#should_panicでパニックを確認する">should_panicでパニックを確認する</a></h2>
<p>期待する正しい値をコードが返すことを確認することに加えて、想定通りにコードがエラー状態を扱っていることを確認するのも重要です。 例えば、第9章のリスト9-10で生成したGuess型を考えてください。Guessを使用する他のコードは、 Guessのインスタンスは1から100の範囲の値しか含まないという保証に依存しています。 その範囲外の値でGuessインスタンスを生成しようとするとパニックすることを確認するテストを書くことができます。</p>
<p>これは、テスト関数にshould_panicという別の属性を追加することで達成できます。 この属性は、関数内のコードがパニックしたら、テストを通過させます。つまり、 関数内のコードがパニックしなかったら、テストは失敗するわけです。</p>
<p>リスト11-8は、予想どおりにGuess::newのエラー条件が発生していることを確認するテストを示しています。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            //予想値は1から100の間でなければなりませんが、{}でした。
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}

fn main() {}
</code></pre></pre>
<p>リスト11-8: 状況がpanic!を引き起こすとテストする</p>
<p>#[test]属性の後、適用するテスト関数の前に#[should_panic]属性を配置しています。 このテストが通るときの結果を見ましょう:</p>
<pre><code>$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>よさそうですね！では、値が100より大きいときにnew関数がパニックするという条件を除去することでコードにバグを導入しましょう:</p>
<blockquote>
<p>関数の実行結果がパニックになる可能性のある関数を実行した時にパニックすればテスト成功というテストを実施する</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">pub struct Guess {
    value: i32,
}

// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            //予想値は1から100の間でなければなりませんが、{}でした。
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}

fn main() {}
</code></pre></pre>
<p>リスト11-8のテストを実行すると、失敗するでしょう:</p>
<pre><code>$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>この場合、それほど役に立つメッセージは得られませんが、テスト関数に目を向ければ、 #[should_panic]で注釈されていることがわかります。得られた失敗は、 テスト関数のコードがパニックを引き起こさなかったことを意味するのです。</p>
<p>should_panicを使用するテストは不正確なこともあります。なぜなら、コードが何らかのパニックを起こしたことしか示さないからです。 should_panicのテストは、起きると想定していたもの以外の理由でテストがパニックしても通ってしまうのです。 should_panicのテストの正確を期すために、should_panic属性にexpected引数を追加することもできます。 このテストハーネスは、失敗メッセージに与えられたテキストが含まれていることを確かめてくれます。 例えば、リスト11-9の修正されたGuessのコードを考えてください。ここでは、 new関数は、値が大きすぎるか小さすぎるかによって異なるメッセージでパニックします。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">pub struct Guess {
    value: i32,
}

// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                //予想値は1以上でなければなりませんが、{}でした。
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                //予想値は100以下でなければなりませんが、{}でした。
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    //予想値は100以下でなければなりません
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}

fn main() {}
</code></pre></pre>
<blockquote>
<p>パニックが発生したことしかわからないのが欠点でもある</p>
</blockquote>
<p>リスト11-9: 状況が特定のパニックメッセージでpanic!を引き起こすことをテストする</p>
<p>should_panic属性のexpected引数に置いた値がGuess::new関数がパニックしたメッセージの一部になっているので、 このテストは通ります。予想されるパニックメッセージ全体を指定することもでき、今回の場合、 Guess value must be less than or equal to 100, got 200.となります。 should_panicの予想される引数に何を指定するかは、パニックメッセージのどこが固有でどこが動的か、 またテストをどの程度正確に行いたいかによります。今回の場合、パニックメッセージの一部でも、テスト関数内のコードが、 else if value &gt; 100の場合を実行していると確認するのに事足りるのです。</p>
<p>expectedメッセージありのshould_panicテストが失敗すると何が起きるのが確かめるために、 if value &lt; 1とelse if value &gt; 100ブロックの本体を入れ替えることで再度コードにバグを仕込みましょう:</p>
<blockquote>
<p>should_panicでパニック時のメッセージでどのようなパニックが発生するかをテストで確認できる。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                //予想値は100以下でなければなりませんが、{}でした。
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                //予想値は1以上でなければなりませんが、{}でした。
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>should_panicテストを実行すると、今回は失敗するでしょう:</p>
<pre><code>$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;Guess value must be less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>この失敗メッセージは、このテストが確かに予想通りパニックしたことを示していますが、 パニックメッセージは、予想される文字列の'Guess value must be less than or equal to 100'を含んでいませんでした。 実際に得られたパニックメッセージは今回の場合、Guess value must be greater than or equal to 1, got 200でした。 そうしてバグの所在地を割り出し始めることができるわけです！</p>
<h2 id="resultt-eをテストで使う"><a class="header" href="#resultt-eをテストで使う">Result&lt;T, E&gt;をテストで使う</a></h2>
<p>これまでは、失敗するとパニックするようなテストを書いてきましたが、 Result&lt;T, E&gt;を使うようなテストを書くこともできます！ 以下は、Listing 11-1のテストを、Result&lt;T, E&gt;を使い、パニックする代わりにErrを返すように書き直したものです：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
}
</code></pre></pre>
<p>it_works関数の戻り値の型はResult&lt;(), String&gt;になりました。 関数内でassert_eq!マクロを呼び出す代わりに、テストが成功すればOk(())を、失敗すればErrにStringを入れて返すようにします。</p>
<p>Result&lt;T, E&gt; を返すようなテストを書くと、?演算子をテストの中で使えるようになります。 これは、テスト内で何らかの工程がErrヴァリアントを返したときに失敗するべきテストを書くのに便利です。</p>
<p>Result&lt;T, E&gt;を使うテストに#[should_panic]注釈を使うことはできません。 テストが失敗しなければならないときは、直接Err値を返してください。</p>
<p>今やテスト記法を複数知ったので、テストを走らせる際に起きていることに目を向け、 cargo testで使用できるいろんなオプションを探究しましょう。</p>
<blockquote>
<p>resultのOK、Errを使用してテストをすることも可能です。</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="テストの実行のされ方を制御する"><a class="header" href="#テストの実行のされ方を制御する">テストの実行のされ方を制御する</a></h1>
<p>cargo runがコードをコンパイルし、出来上がったバイナリを走らせるのと全く同様に、 cargo testはコードをテストモードでコンパイルし、出来上がったテストバイナリを実行します。 コマンドラインオプションを指定してcargo testの既定動作を変更することができます。 例えば、cargo testで生成されるバイナリの既定動作は、テストを全て並行に実行し、 テスト実行中に生成された出力をキャプチャして出力が表示されるのを防ぎ、 テスト結果に関係する出力を読みやすくすることです。</p>
<p>コマンドラインオプションの中にはcargo testにかかるものや、出来上がったテストバイナリにかかるものがあります。 この2種の引数を区別するために、cargo testにかかる引数を--という区分記号の後に列挙し、 それからテストバイナリにかかる引数を列挙します。cargo test --helpを走らせると、cargo testで使用できるオプションが表示され、 cargo test -- --helpを走らせると、--という区分記号の後に使えるオプションが表示されます。</p>
<h2 id="テストを並行または連続して実行する"><a class="header" href="#テストを並行または連続して実行する">テストを並行または連続して実行する</a></h2>
<p>複数のテストを実行するとき、標準では、スレッドを使用して並行に走ります。これはつまり、 テストが早く実行し終わり、コードが機能しているいかんにかかわらず、反応をより早く得られることを意味します。 テストは同時に実行されているので、テストが相互や共有された環境を含む他の共通の状態に依存してないことを確かめてください。 現在の作業対象ディレクトリや環境変数などですね。</p>
<p>例えば、各テストがディスクにtest_output.txtというファイルを作成し、何らかのデータを書き込むコードを走らせるとしてください。 そして、各テストはそのファイルのデータを読み取り、ファイルが特定の値を含んでいるとアサーションし、 その値は各テストで異なります。テストが同時に走るので、あるテストが、 他のテストが書き込んだり読み込んだりする間隙にファイルを上書きするかもしれません。 それから2番目のテストが失敗します。コードが不正だからではなく、 並行に実行されている間にテストがお互いに邪魔をしてしまったせいです。 各テストが異なるファイルに書き込むことを確かめるのが一つの解決策です; 別の解決策では、 一度に一つのテストを実行します。</p>
<p>並行にテストを実行したくなかったり、使用されるスレッド数をよりきめ細かく制御したい場合、 --test-threadsフラグと使用したいスレッド数をテストバイナリに送ることができます。 以下の例に目を向けてください:</p>
<pre><code>$ cargo test -- --test-threads=1
</code></pre>
<p>テストスレッドの数を1にセットし、並行性を使用しないようにプログラムに指示しています。 1スレッドのみを使用してテストを実行すると、並行に実行するより時間がかかりますが、 状態を共有していても、お互いに邪魔をすることはありません。</p>
<blockquote>
<p>テストをするときにスレッドの数を制御することによって依存関係のあるコードもテストができるが、時間はかかりますよという形です。</p>
<p>これは色々やってみないとわからないですね。</p>
</blockquote>
<h2 id="関数の出力を表示する"><a class="header" href="#関数の出力を表示する">関数の出力を表示する</a></h2>
<p>標準では、テストが通ると、Rustのテストライブラリは標準出力に出力されたものを全てキャプチャします。例えば、 テストでprintln!を呼び出してテストが通ると、println!の出力は、端末に表示されません; テストが通ったことを示す行しか見られないでしょう。テストが失敗すれば、 残りの失敗メッセージと共に、標準出力に出力されたものが全て見えるでしょう。</p>
<p>例として、リスト11-10は引数の値を出力し、10を返す馬鹿げた関数と通過するテスト1つ、失敗するテスト1つです。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
fn prints_and_returns_10(a: i32) -&gt; i32 {
    //{}という値を得た
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
}
</code></pre></pre>
<p>リスト11-10: println!を呼び出す関数用のテスト</p>
<p>これらのテストをcargo testで実行すると、以下のような出力を目の当たりにするでしょう:</p>
<pre><code>running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
        I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>この出力のどこにも I got the value 4 と表示されていないことに注意してください。 これは、テストに合格した場合に出力されるものです。 その出力はキャプチャされてしまいました。 失敗したテストのからの出力 I got the value 8 がテストサマリー出力のセクションに表示され、テストが失敗した原因も示されます。</p>
<p>通過するテストについても出力される値が見たかったら、出力キャプチャ機能を--nocaptureフラグで無効化することができます:</p>
<pre><code>$ cargo test -- --nocapture
</code></pre>
<p>リスト11-10のテストを--nocaptureフラグと共に再度実行したら、以下のような出力を目の当たりにします:</p>
<pre><code>running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>テスト用の出力とテスト結果の出力がまぜこぜになっていることに注意してください; その理由は、前節で語ったようにテストが並行に実行されているからです。 -test-threads=1オプションと--nocaptureフラグを使ってみて、 その時、出力がどうなるか確かめてください！</p>
<h2 id="名前でテストの一部を実行する"><a class="header" href="#名前でテストの一部を実行する">名前でテストの一部を実行する</a></h2>
<p>時々、全テストを実行すると時間がかかってしまうことがあります。特定の部分のコードしか対象にしていない場合、 そのコードに関わるテストのみを走らせたいかもしれません。cargo testに走らせたいテストの名前を引数として渡すことで、 実行するテストを選ぶことができます。</p>
<p>テストの一部を走らせる方法を模擬するために、リスト11-11に示したように、 add_two関数用に3つテストを作成し、走らせるテストを選択します。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
}
</code></pre></pre>
<p>リスト11-11: 異なる名前の3つのテスト</p>
<p>以前見かけたように、引数なしでテストを走らせたら、全テストが並行に走ります:</p>
<pre><code>running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2 id="単独のテストを走らせる"><a class="header" href="#単独のテストを走らせる">単独のテストを走らせる</a></h2>
<p>あらゆるテスト関数の名前をcargo testに渡して、そのテストのみを実行することができます:</p>
<blockquote>
<p>一つのテストコードだけ走らせたい場合もできます。</p>
</blockquote>
<pre><code>$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>one_hundredという名前のテストだけが走りました; 他の2つのテストはその名前に合致しなかったのです。 まとめ行の最後に2 filtered outと表示することでテスト出力は、このコマンドが走らせた以上のテストがあることを知らせてくれています。</p>
<p>この方法では、複数のテストの名前を指定することはできません; cargo testに与えられた最初の値のみが使われるのです。 ですが、複数のテストを走らせる方法もあります。</p>
<h2 id="複数のテストを実行するようフィルターをかける"><a class="header" href="#複数のテストを実行するようフィルターをかける">複数のテストを実行するようフィルターをかける</a></h2>
<p>テスト名の一部を指定でき、その値に合致するあらゆるテストが走ります。例えば、 我々のテストの2つがaddという名前を含むので、cargo test addを実行することで、その二つを走らせることができます:</p>
<pre><code>$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>このコマンドは名前にaddを含むテストを全て実行し、one_hundredという名前のテストを除外しました。 また、テストが出現するモジュールがテスト名の一部になっていて、 モジュール名でフィルターをかけることで、あるモジュール内のテスト全てを実行できることに注目してください。</p>
<h2 id="特に要望のない限りテストを無視する"><a class="header" href="#特に要望のない限りテストを無視する">特に要望のない限りテストを無視する</a></h2>
<p>時として、いくつかの特定のテストが実行するのに非常に時間がかかることがあり、 cargo testの実行のほとんどで除外したくなるかもしれません。引数として確かに実行したいテストを全て列挙するのではなく、 ここに示したように代わりに時間のかかるテストをignore属性で除外すると注釈することができます。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // 実行に1時間かかるコード
    // code that takes an hour to run
}
}
</code></pre></pre>
<p>#[test]の後の除外したいテストに#[ignore]行を追加しています。これで、 テストを実行したら、it_worksは実行されるものの、expensive_testは実行されません:</p>
<blockquote>
<p>テスト全体で無視することもできます。</p>
</blockquote>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>expensive_test関数は、ignoredと列挙されています。無視されるテストのみを実行したかったら、 cargo test -- --ignoredを使うことができます:</p>
<pre><code>$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>どのテストを走らせるか制御することで、結果が早く出ることを確かめることができるのです。 ignoredテストの結果を確認することが道理に合い、結果を待つだけの時間ができたときに、 代わりにcargo test -- --ignoredを走らせることができます。</p>
<blockquote>
<p>testコードに関しては色々なテストができます。戦略的に考えて色々やっていきましょう！</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="テストの体系化"><a class="header" href="#テストの体系化">テストの体系化</a></h1>
<p>章の初めで触れたように、テストは複雑な鍛錬であり、人によって専門用語や体系化が異なります。 Rustのコミュニティでは、テストを2つの大きなカテゴリで捉えています: 単体テストと結合テストです。 単体テストは小規模でより集中していて、個別に1回に1モジュールをテストし、非公開のインターフェイスもテストすることがあります。 結合テストは、完全にライブラリ外になり、他の外部コード同様に自分のコードを使用し、公開インターフェイスのみ使用し、 1テストにつき複数のモジュールを用いることもあります。</p>
<p>どちらのテストを書くのも、ライブラリの一部が個別かつ共同でしてほしいことをしていることを確認するのに重要なのです。</p>
<h2 id="単体テスト"><a class="header" href="#単体テスト">単体テスト</a></h2>
<p>単体テストの目的は、残りのコードから切り離して各単位のコードをテストし、 コードが想定通り、動いたり動いていなかったりする箇所を迅速に特定することです。 単体テストは、テスト対象となるコードと共に、srcディレクトリの各ファイルに置きます。 慣習は、各ファイルにtestsという名前のモジュールを作り、テスト関数を含ませ、 そのモジュールをcfg(test)で注釈することです。</p>
<h2 id="テストモジュールとcfgtest"><a class="header" href="#テストモジュールとcfgtest">テストモジュールと#[cfg(test)]</a></h2>
<p>testsモジュールの#[cfg(test)]という注釈は、コンパイラにcargo buildを走らせた時ではなく、cargo testを走らせた時にだけ、 テストコードをコンパイルし走らせるよう指示します。これにより、ライブラリをビルドしたいだけの時にはコンパイルタイムを節約し、 テストが含まれないので、コンパイル後の成果物のサイズも節約します。結合テストは別のディレクトリに存在することになるので、 #[cfg(test)]注釈は必要ないとわかるでしょう。しかしながら、単体テストはコードと同じファイルに存在するので、 #[cfg(test)]を使用してコンパイル結果に含まれないよう指定するのです。</p>
<p>この章の最初の節で新しいadderプロジェクトを生成した時に、Cargoがこのコードも生成してくれたことを思い出してください:</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
}
</code></pre></pre>
<p>このコードが自動生成されたテストモジュールです。cfgという属性は、configurationを表していて、 コンパイラに続く要素が、ある特定の設定オプションを与えられたら、含まれるように指示します。 今回の場合、設定オプションは、testであり、言語によって提供されているテストをコンパイルし、 走らせるためのものです。cfg属性を使用することで、cargo testで積極的にテストを実行した場合のみ、 Cargoがテストコードをコンパイルします。これには、このモジュールに含まれるかもしれないヘルパー関数全ても含まれ、 #[test]で注釈された関数だけにはなりません。</p>
<h2 id="非公開関数をテストする"><a class="header" href="#非公開関数をテストする">非公開関数をテストする</a></h2>
<p>テストコミュニティ内で非公開関数を直接テストするべきかについては議論があり、 他の言語では非公開関数をテストするのは困難だったり、不可能だったりします。 あなたがどちらのテストイデオロギーを支持しているかに関わらず、Rustの公開性規則により、 非公開関数をテストすることが確かに可能です。リスト11-12の非公開関数internal_adderを含むコードを考えてください。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
}
</code></pre></pre>
<blockquote>
<p>ここではinternal_adderの関数が非公開です。他の言語ではこの非公開な関数についてテストしなくてもいいんじゃない？という動きがあると主張しているのでしょう。</p>
</blockquote>
<p>リスト11-12: 非公開関数をテストする</p>
<p>internal_adder関数はpubとマークされていないものの、テストも単なるRustのコードであり、 testsモジュールもただのモジュールでしかないので、テスト内でinternal_adderを普通にインポートし呼び出すことができます。 非公開関数はテストするべきではないとお考えなら、Rustにはそれを強制するものは何もありません。</p>
<blockquote>
<p>これは考えによります。まずはテストがどういうものなのか把握する必要があるので、どんどんテストは書いていきましょう！</p>
</blockquote>
<h2 id="結合テスト"><a class="header" href="#結合テスト">結合テスト</a></h2>
<p>Rustにおいて、結合テストは完全にライブラリ外のものです。他のコードと全く同様にあなたのライブラリを使用するので、 ライブラリの公開APIの一部である関数しか呼び出すことはできません。その目的は、 ライブラリのいろんな部分が共同で正常に動作しているかをテストすることです。 単体では正常に動くコードも、結合した状態だと問題を孕む可能性もあるので、 結合したコードのテストの範囲も同様に重要になるのです。結合テストを作成するには、 まずtestsディレクトリが必要になります。</p>
<blockquote>
<p>「結合テストを作成するには、まずtestsディレクトリが必要になります</p>
</blockquote>
<h2 id="testsディレクトリ"><a class="header" href="#testsディレクトリ">testsディレクトリ</a></h2>
<p>プロジェクトディレクトリのトップ階層、srcの隣にtestsディレクトリを作成します。 Cargoは、このディレクトリに結合テストのファイルを探すことを把握しています。 そして、このディレクトリ内にいくらでもテストファイルを作成することができ、 Cargoはそれぞれのファイルを個別のクレートとしてコンパイルします。</p>
<p>結合テストを作成しましょう。リスト11-12のコードがsrc/lib.rsファイルにあるまま、 testsディレクトリを作成し、tests/integration_test.rsという名前の新しいファイルを生成し、 リスト11-13のコードを入力してください。</p>
<p>ファイル名: tests/integration_test.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
<span class="boring">}
</span></code></pre></pre>
<p>リスト11-13: adderクレートの関数の結合テスト</p>
<p>コードの頂点にextern crate adderを追記しましたが、これは単体テストでは必要なかったものです。 理由は、testsディレクトリのテストはそれぞれ個別のクレートであるため、 各々ライブラリをインポートする必要があるためです。</p>
<p>tests/integration_test.rsのどんなコードも#[cfg(test)]で注釈する必要はありません。 Cargoはtestsディレクトリを特別に扱い、cargo testを走らせた時にのみこのディレクトリのファイルをコンパイルするのです。 さあ、cargo testを実行してください:</p>
<pre><code>$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>3つの区域の出力が単体テスト、結合テスト、ドックテストを含んでいます。単体テスト用の最初の区域は、 今まで見てきたものと同じです: 各単体テストに1行(リスト11-12で追加したinternalという名前のもの)と、 単体テストのサマリー行です。</p>
<p>結合テストの区域は、 Running target/debug/deps/integration-test-ce99bcc2479f4607という行で始まっています(最後のハッシュはあなたの出力とは違うでしょう)。 次に、この結合テストの各テスト関数用の行があり、Doc-tests adder区域が始まる直前に、 結合テストの結果用のサマリー行があります。</p>
<p>単体テスト関数を追加することで単体テスト区域のテスト結果の行が増えたように、 作成した結合テストファイルにテスト関数を追加することでそのファイルの区域に結果の行が増えることになります。 結合テストファイルはそれぞれ独自の区域があるため、testsディレクトリにさらにファイルを追加すれば、 結合テストの区域が増えることになるでしょう。</p>
<p>それでも、テスト関数の名前を引数としてcargo testに指定することで、特定の結合テスト関数を走らせることができます。 特定の結合テストファイルにあるテストを全て走らせるには、cargo testに--test引数、 その後にファイル名を続けて使用してください:</p>
<blockquote>
<p>1つの結合テストは1つのファイルで実施する</p>
</blockquote>
<pre><code>$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>このコマンドは、tests/integration_test.rsファイルにあるテストのみを実行します。</p>
<h2 id="結合テスト内のサブモジュール"><a class="header" href="#結合テスト内のサブモジュール">結合テスト内のサブモジュール</a></h2>
<p>結合テストを追加するにつれて、testsディレクトリに2つ以上のファイルを作成して体系化したくなるかもしれません; 例えば、テスト対象となる機能でテスト関数をグループ化することができます。前述したように、 testsディレクトリの各ファイルは、個別のクレートとしてコンパイルされます。</p>
<p>各結合テストファイルをそれ自身のクレートとして扱うと、 エンドユーザがあなたのクレートを使用するかのように個別のスコープを生成するのに役立ちます。 ですが、これはtestsディレクトリのファイルが、コードをモジュールとファイルに分ける方法に関して第7章で学んだように、 srcのファイルとは同じ振る舞いを共有しないことを意味します。</p>
<p>testsディレクトリのファイルの異なる振る舞いは、複数の結合テストファイルで役に立ちそうなヘルパー関数ができ、 第7章の「モジュールを別のファイルに移動する」節の手順に従って共通モジュールに抽出しようとした時に最も気付きやすくなります。 例えば、tests/common.rsを作成し、そこにsetupという名前の関数を配置したら、 複数のテストファイルの複数のテスト関数から呼び出したいsetupに何らかのコードを追加することができます:</p>
<p>ファイル名: tests/common.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
pub fn setup() {
    // ここにライブラリテスト固有のコードが来る
    // setup code specific to your library's tests would go here
}
}
</code></pre></pre>
<p>再度テストを実行すると、common.rsファイルは何もテスト関数を含んだり、setup関数をどこかから呼んだりしてないのに、 テスト出力にcommon.rs用の区域が見えるでしょう。</p>
<pre><code>running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70 // これは望んだ結果ではない。

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>commonがrunning 0 testsとテスト結果に表示されるのは、望んだ結果ではありません。 ただ単に他の結合テストファイルと何らかのコードを共有したかっただけです。</p>
<p>commonがテスト出力に出現するのを防ぐには、tests/common.rsを作成する代わりに、 tests/common/mod.rsを作成します。第7章の「モジュールファイルシステムの規則」節において、 module_name/mod.rsという命名規則をサブモジュールのあるモジュールのファイルに使用しました。 ここではcommonにサブモジュールはありませんが、 このように命名することでコンパイラにcommonモジュールを結合テストファイルとして扱わないように指示します。 setup関数のコードをtests/common/mod.rsに移動し、tests/common.rsファイルを削除すると、 テスト出力に区域はもう表示されなくなります。testsディレクトリのサブディレクトリ内のファイルは個別クレートとしてコンパイルされたり、 テスト出力に区域が表示されることがないのです。</p>
<p>tests/common/mod.rsを作成した後、それをどの結合テストファイルからもモジュールとして使用することができます。 こちらは、tests/integration_test.rs内のit_adds_twoテストからsetup関数を呼び出す例です:</p>
<p>ファイル名: tests/integration_test.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
<span class="boring">}
</span></code></pre></pre>
<p>mod common;という宣言は、リスト7-21で模擬したモジュール宣言と同じであることに注意してください。それから、テスト関数内でcommon::setup()関数を呼び出すことができます。</p>
<blockquote>
<p>testsの配下だと結合テストファイルとして認識されているのかな？またサブディレクトリ以下のファイルは結合テストファイルとして認識されるのかな？</p>
</blockquote>
<h2 id="バイナリクレート用の結合テスト"><a class="header" href="#バイナリクレート用の結合テスト">バイナリクレート用の結合テスト</a></h2>
<p>もしもプロジェクトがsrc/main.rsファイルのみを含み、src/lib.rsファイルを持たないバイナリクレートだったら、 testsディレクトリに結合テストを作成し、 extern crateを使用してsrc/main.rsファイルに定義された関数をインポートすることはできません。 ライブラリクレートのみが、他のクレートが呼び出して使用できる関数を晒せるのです; バイナリクレートはそれ単体で実行することを意味しています。</p>
<p>これは、バイナリを提供するRustのプロジェクトに、 src/lib.rsファイルに存在するロジックを呼び出す単純なsrc/main.rsファイルがある一因になっています。 この構造を使用して結合テストは、extern crateを使用して重要な機能を用いることでライブラリクレートをテストすることができます。 この重要な機能が動作すれば、src/main.rsファイルの少量のコードも動作し、その少量のコードはテストする必要がないわけです。</p>
<h1 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h1>
<p>Rustのテスト機能は、変更を加えた後でさえ想定通りにコードが機能し続けることを保証して、 コードが機能すべき方法を指定する手段を提供します。単体テストはライブラリの異なる部分を個別に用い、 非公開の実装詳細をテストすることができます。結合テストは、ライブラリのいろんな部分が共同で正常に動作することを確認し、 ライブラリの公開APIを使用して外部コードが使用するのと同じ方法でコードをテストします。 Rustの型システムと所有権ルールにより防がれるバグの種類もあるものの、それでもテストは、 コードが振る舞うと予想される方法に関するロジックのバグを減らすのに重要なのです。</p>
<p>この章と以前の章で学んだ知識を結集して、とあるプロジェクトに取り掛かりましょう！</p>
<p><a href="https://www.youtube.com/watch?v=18-7NoNPO30&amp;list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&amp;index=13">参考URL1</a>
<a href="https://www.youtube.com/watch?v=-L4nKAlmH3M&amp;list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8&amp;index=14">参考URL2</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
