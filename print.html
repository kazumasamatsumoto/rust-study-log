<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-study-log</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="generic_trait_liftime/june.html"><strong aria-hidden="true">1.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generic_trait_liftime/trait.html"><strong aria-hidden="true">1.1.</strong> トレイト：共通の振る舞いを定義する</a></li><li class="chapter-item expanded "><a href="generic_trait_liftime/lifetime.html"><strong aria-hidden="true">1.2.</strong> ライフタイムで参照を検証する</a></li></ol></li><li class="chapter-item expanded "><a href="auto_tests/writing_automated_tests.html"><strong aria-hidden="true">2.</strong> 自動テストを書く</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="auto_tests/how_to_wirite_tests.html"><strong aria-hidden="true">2.1.</strong> テストの記述法</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">rust-study-log</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ジェネリック型トレイトライフタイム"><a class="header" href="#ジェネリック型トレイトライフタイム">ジェネリック型、トレイト、ライフタイム</a></h1>
<p>全てのプログラミング言語には、概念の重複を効率的に扱う道具があります。Rustにおいて、そのような道具の一つがジェネリクスです。 ジェネリクスは、具体型や他のプロパティの抽象的な代役です。コード記述の際、コンパイルやコード実行時に、 ジェネリクスの位置に何が入るかを知ることなく、ジェネリクスの振る舞いや他のジェネリクスとの関係を表現できるのです。</p>
<p>関数が未知の値の引数を取り、同じコードを複数の具体的な値に対して走らせるように、 i32やStringなどの具体的な型の代わりに何かジェネリックな型の引数を取ることができます。 実際、第6章でOption<T>、第8章でVec<T>とHashMap&lt;K, V&gt;、第9章でResult&lt;T, E&gt;を既に使用しました。 この章では、独自の型、関数、メソッドをジェネリクスとともに定義する方法を探究します！</p>
<p>まず、関数を抽出して、コードの重複を減らす方法を確認しましょう。次に同じテクニックを活用して、 引数の型のみが異なる2つの関数からジェネリックな関数を生成します。また、 ジェネリックな型を構造体やenum定義で使用する方法も説明します。</p>
<p>それから、トレイトを使用して、ジェネリックな方法で振る舞いを定義する方法を学びます。 ジェネリックな型にトレイトを組み合わせることで、ジェネリックな型を、単にあらゆる型に対してではなく、特定の振る舞いのある型のみに制限できます。</p>
<p>最後に、ライフタイムを議論します。ライフタイムとは、コンパイラに参照がお互いにどう関係しているかの情報を与える一種のジェネリクスです。 ライフタイムのおかげでコンパイラに参照が有効であることを確認してもらうことを可能にしつつ、多くの場面で値を借用できます。</p>
<h2 id="関数を抽出することで重複を取り除く"><a class="header" href="#関数を抽出することで重複を取り除く">関数を抽出することで重複を取り除く</a></h2>
<p>ジェネリクスの記法に飛び込む前にまずは、関数を抽出することでジェネリックな型が関わらない重複を取り除く方法を見ましょう。 そして、このテクニックを適用してジェネリックな関数を抽出するのです！重複したコードを認識して関数に抽出できるのと同じように、 ジェネリクスを使用できる重複コードも認識し始めるでしょう。</p>
<p>リスト10-1に示したように、リスト内の最大値を求める短いプログラムを考えてください。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    // 最大値は{}です
    println!(&quot;The largest number is {}&quot;, largest);
 assert_eq!(largest, 100);
}
</code></pre></pre>
<p>リスト10-1: 数字のリストから最大値を求めるコード</p>
<p>このコードは、整数のリストを変数number_listに格納し、リストの最初の数字をlargestという変数に配置しています。 それからリストの数字全部を走査し、現在の数字がlargestに格納された数値よりも大きければ、 その変数の値を置き換えます。ですが、現在の数値が今まで見た最大値よりも小さければ、 変数は変わらず、コードはリストの次の数値に移っていきます。リストの数値全てを吟味した後、 largestは最大値を保持しているはずで、今回は100になります。</p>
<p>2つの異なる数値のリストから最大値を発見するには、リスト10-1のコードを複製し、 プログラムの異なる2箇所で同じロジックを使用できます。リスト10-2のようにですね。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p>リスト10-2: 2つの数値のリストから最大値を探すコード</p>
<p>このコードは動くものの、コードを複製することは退屈ですし、間違いも起きやすいです。また、 コードを変更したい時に複数箇所、更新しなければなりません。</p>
<p>この重複を排除するには、引数で与えられた整数のどんなリストに対しても処理が行える関数を定義して抽象化できます。 この解決策によりコードがより明確になり、リストの最大値を探すという概念を抽象的に表現させてくれます。</p>
<p>リスト10-3では、最大値を探すコードをlargestという関数に抽出しました。リスト10-1のコードは、 たった1つの特定のリストからだけ最大値を探せますが、それとは異なり、このプログラムは2つの異なるリストから最大値を探せます。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
   assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
   assert_eq!(result, 6000);
}
</code></pre></pre>
<p>リスト10-3: 2つのリストから最大値を探す抽象化されたコード</p>
<p>largest関数にはlistと呼ばれる引数があり、これは、関数に渡す可能性のある、あらゆるi32値の具体的なスライスを示します。 結果的に、関数呼び出しの際、コードは渡した特定の値に対して走るのです。</p>
<p>まとめとして、こちらがリスト10-2のコードからリスト10-3に変更するのに要したステップです:</p>
<p>重複したコードを見分ける。
重複コードを関数本体に抽出し、コードの入力と戻り値を関数シグニチャで指定する。
重複したコードの2つの実体を代わりに関数を呼び出すように更新する。
次は、この同じ手順をジェネリクスでも踏んで異なる方法でコードの重複を減らします。 関数本体が特定の値ではなく抽象的なlistに対して処理できたのと同様に、 ジェネリクスは抽象的な型に対して処理するコードを可能にしてくれます。</p>
<p>例えば、関数が2つあるとしましょう: 1つはi32値のスライスから最大の要素を探し、1つはchar値のスライスから最大要素を探します。 この重複はどう排除するのでしょうか？答えを見つけましょう！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="2022-年-6-月-29-日"><a class="header" href="#2022-年-6-月-29-日">2022 年 6 月 29 日</a></h1>
<h2 id="今日の学習内容"><a class="header" href="#今日の学習内容">今日の学習内容</a></h2>
<p>トレイト：共通の振る舞いを定義する</p>
<h3 id="トレイト共通の振る舞いを定義する"><a class="header" href="#トレイト共通の振る舞いを定義する">トレイト:共通の振る舞いを定義する</a></h3>
<p>トレイトは、Rust コンパイラに、特定の型に存在し、他の型と共有できる機能について知らせます。
トレイトを使用すると、共通の振る舞いを抽象的に定義できます。
トレイト境界を使用すると、あるジェネリックが、特定の振る舞いをもつあらゆる型になり得ることを指定できます。</p>
<blockquote>
<p>トレイトの機能としては</p>
<p>・Rust コンパイラに知らせる（特定の型に存在し、他の方と共有できる機能について）</p>
<p>・共通の振る舞いを抽象的に定義できます</p>
<p>・トレイト境界というのがある</p>
<p>・とあるジェネリックが、特定の振る舞いをもつあらゆる型になり得る</p>
</blockquote>
<p>という機能があったりするということです。</p>
<blockquote>
<p>注釈：違いはあるものの、トレイトは他の言語でよくインターフェイスと呼ばれる機能に類似しています。</p>
</blockquote>
<h4 id="トレイトを定義する"><a class="header" href="#トレイトを定義する">トレイトを定義する</a></h4>
<p>型の振る舞いは、その型に対して呼び出せるメソッドから構成されます。異なる型は、それらの型全てに対して同じメソッドを呼び出せるなら、同じ振る舞いを共有することになります。トレイト定義は、メソッドシグニチャをあるグループにまとめ、なんらかの目的を達成するのに必要な一連の振る舞いを定義する手段です。</p>
<blockquote>
<p>基本的な考え方としては型の定義が違うけど、実際のロジックは同じという状況が発生すると、同じコードを再度書くのが DRY（Don't Repeat Yourself)の原則から外れるからやめた方がいいよということです。（別に使っても問題ないです。一緒に働く仲間からは嫌われる可能性があるので、仲良くしたい人はうまく書けないことを伝えておくか、共通化が必要になったときにどのようにしたらいいのか？テックリードあたりに確認するのがいいです）</p>
<p>で、そのテックリードとかが「知るか！」という場合はあっていないので職場を離れましょう。基本的にコード戦略等は指揮をとる人に確認します。自分勝手なコードを書かないように、この時強い言葉（パンチラインの効いた言葉）を使う人とは仕事をするのは要注意です。（京都的な嫌味な言い回しも気をつけましょう）「結構学生の頃頑張ってたんですね。」とかは「お前のコードは学生レベルだからな」という言い回しですので、非常に気をつけましょう。</p>
</blockquote>
<p>例えば、いろんな種類や量のテキストを保持する複数の構造体があるとしましょう:特定の場所から送られる新しいニュースを保持する<code>NewsArticle</code>と、新規ツイートか、リツイートか、はたまた他のツイートへのリプライなのかを示すメタデータを伴う最大で 280 文字までの<code>Tweet</code>です。</p>
<p><code>NewsArticle</code>または<code>Tweet</code>インスタンスに保存されているデータのサマリーを表示できるメディアアグリゲータライブラリを作成します。これをするには、各型のサマリーが必要で、インスタンスで<code>summarize</code>メソッドを呼び出してサマリーを要求する必要があります。リスト 10-12 は、この振る舞いを表現する<code>Summary</code>トレイトの定義を表示しています。</p>
<blockquote>
<p>要するにここではツイートやニュース記事の統計データと目次を表示できるライブラリを作ろうとします。アグリゲートは「集める」や「合計する」「集計する」という意味があります。なのでイメージとしては 2ch まとめサイトがいいかと思います。</p>
</blockquote>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>リスト 10-12: <code>summarize</code>メソッドで提供される振る舞いからなる<code>Summary</code>トレイト</strong></p>
<p>ここでは、trait キーワード、それからトレイト名を使用してトレイトを定義していて、その名前は今回の場合、Summary です。波括弧の中にこのトレイトを実装する型の振る舞いを記述するメソッドシグニチャを定義し、今回の場合は、fn summarize(&amp;self) -&gt; String です。</p>
<blockquote>
<p>pub trait と宣言することで外部ファイルでも使用できる trait（振る舞い）を定義することができます。
この場合の振る舞いは Summary と言う振る舞いでその中身は fn summarize(&amp;self) -&gt; String
と言う返り値が文字列の配列になる形です。</p>
</blockquote>
<p>メソッドシグニチャの後に、波括弧内に実装を提供する代わりに、セミコロンを使用しています。このトレイトを実装する型はそれぞれ、メソッドの本体に独自の振る舞いを提供しなければなりません。コンパイラにより、Summary トレイトを保持するあらゆる型に、このシグニチャと全く同じメソッド summarize が定義されていることが強制されます。</p>
<p>トレイトには、本体に複数のメソッドを含むことができます:メソッドシグニチャは行ごとに並べられ、各行はセミコロンで終わります。</p>
<h4 id="トレイトを型に実装する"><a class="header" href="#トレイトを型に実装する">トレイトを型に実装する</a></h4>
<p>今や Summary トレイトを使用して目的の動作を定義できたので、
メディアアグリゲータでこれを型に実装できます。
リスト 10-13 は、Summary トレイトを NewsArticle 構造体上に実装したもので、
ヘッドライン、著者、そして地域情報を使って summarize の戻り値を作っています。
Tweet 構造体に関しては、ツイートの内容が既に 280 文字に制限されていると仮定して、
ユーザー名の後にツイートのテキスト全体が続くものとして summarize を定義します。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">   pub trait Summary {
</span><span class="boring">       fn summarize(&amp;self) -&gt; String
</span><span class="boring">   }
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>型にトレイトを実装することは、普通のメソッドを実装することに似ています。
違いは、impl の後に、実装したいトレイトの名前を置き、それから for キーワード、
さらにトレイトの実装対象の型の名前を指定することです。
impl ブロック内に、トレイト定義で定義したメソッドシグニチャを置きます。
各シグニチャの後にセミコロンを追記するのではなく、波括弧を使用し、
メソッド本体に特定の型のトレイトのメソッドに欲しい特定の振る舞いを入れます。</p>
<p>トレイトを実装後、普通のメソッド同様に NewsArticle や Tweet のインスタンスに対してこのメソッドを呼び出せます。 こんな感じで:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use chapter10::{self, Summary, Tweet};
</span>
<span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre></pre>
<p>このコードは、1 new tweet: horse_ebooks: of course, as you probably already know, people と出力します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>感想メモ：</p>
<p>ここで self.username と self.content の 2 つに関してフォーマットを実施すると言う内容になっています。
ですので、Tweet については username と content については自身の文字列の引数を受け取って関数を実行します。
ポイントはあくまでも共通化処理なので、一つずつの構造体のキー名に対して impl を実装することも可能ですが、
こちらの方が都合がいいのでは？と言うのが感想です（甘いかもしれませんが。）</p>
</blockquote>
<p>リスト 10-13 で Summary トレイトと NewArticle、Tweet 型を同じ lib.rs に定義したので、
全部同じスコープにあることに注目してください。
この lib.rs を aggregator と呼ばれるクレート専用にして、
誰か他の人が私たちのクレートの機能を活用して自分のライブラリのスコープに
定義された構造体に Summary トレイトを実装したいとしましょう。
まず、トレイトをスコープに取り込む必要があるでしょう。</p>
<p>use aggregator::Summary;</p>
<p>と指定してそれを行えば、これにより、自分の型に Summary を実装することが可能になるでしょう。
Summary トレイトは、他のクレートが実装するためには、公開トレイトである必要があり、
ここでは、リスト 10-12 の trait の前に、pub キーワードを置いたのでそうなっています。</p>
<p>トレイト実装で注意すべき制限の 1 つは、トレイトか対象の型が自分のクレートに固有(local)である時のみ、
型に対してトレイトを実装できるということです。
例えば、Display のような標準ライブラリのトレイトを aggregator クレートの機能の一部として、
Tweet のような独自の型に実装できます。
型 Tweet が aggregator クレートに固有だからです。
また、Summary を aggregator クレートで Vec<T>に対して実装することもできます。
トレイト Summary は、aggregator クレートに固有だからです。</p>
<p>しかし、外部のトレイトを外部の型に対して実装することはできません。
例として、aggregator クレート内で Vec<T>に対して Display トレイトを実装することはできません。
Display と Vec<T>は標準ライブラリで定義され、aggregator クレートに固有ではないからです。
この制限は、コヒーレンス(coherence)、
特に孤児のルール(orphan rule)と呼ばれるプログラムの特性の一部で、
親の型が存在しないためにそう命名されました。
この規則により、他の人のコードが自分のコードを壊したり、
その逆が起きないことを保証してくれます。
この規則がなければ、2 つのクレートが同じ型に対して同じトレイトを実装できてしまい、
コンパイラはどちらの実装を使うべきかわからなくなってしまうでしょう。</p>
<blockquote>
<p>■ コヒーレンス(Coherence：可干渉性)
コヒーレンスとは、波が重なり合ったときの干渉縞の作り易さを示します。</p>
<p>重なり合う波同士の位相、振幅に一定の関係がある場合は、合成された波も一定の位相、振幅をもつので干渉縞ができます。
干渉縞を作れる波をコヒーレントな波といい、レーザ光は代表的なコヒーレントな波（コヒーレント光）です。
一方、位相、振幅がランダムな波は干渉縞を作ることができず、インコヒーレントな波といいます。
電球、LED、SLD、ASE 光源などはインコヒーレントな波（インコヒーレント光）です。</p>
</blockquote>
<blockquote>
<p>ちょっとここ難しいので図式化が必要です。</p>
<p>ここの部分登場人物を整理しないといけないです。</p>
<p>・NewArticle と Tweet と言う二つの型を同じ lib.rs のファイルに定義している</p>
<p>・同じスコープ内にある</p>
<p>・この lib.rs を aggregator と呼ばれるクレート専用にして、誰かの他の人が私たちのクレート機能を活用して自分のライブラリのスコープに定義された構造体に Summary トレイトを実装したいとしましょう。</p>
<p>・まず、トレイトをスコープに取り込む必要があります。</p>
<p>・トレイトを他のクレートが実装するためには定義したトレイトを公開状態にする必要があります。</p>
<p>・トレイト実装で注意すべき制限の 1 つは、トレイトか対象の型が自分のクレートに固有（local）であるときのみ、型に対してトレイトを実装できると言うことです。</p>
<p>・Display のような標準ライブラリのトレイトを aggregator クレートの機能の一部として、Tweet のような独自の型に実装できます。</p>
<p>・型 Tweet が aggregator クレートに固有だからです。</p>
<p>・また Summary を aggregator クレートで Vec<T>に対して実装することもできます。</p>
<p>・トレイト Summary は、aggregator クレートに固有だからです。</p>
<p>・しかし、外部トレイトを外部の型に対して実装することはできません。例として、aggregator クレート内で Vec<T>に対して Display トレイトを実装することはできません。</p>
<p>・Display と Vec<T>は標準ライブラリで定義され、aggregator クレートに固有ではないからです。</p>
<p>・この制限は、コヒーレンス(coherence)、特に孤児のルール(orphan rule)と呼ばれるプログラムの特性の一部で、</p>
<p>・親の型が存在しないためにそう命名されました。この規則により、他の人のコードが自分のコードを壊したり、その逆が起きないことを保証してくれます。この規則がなければ、2 つのクレートが同じ型に対して同じトレイトを実装できてしまい、コンパイラはどちらの実装を使うべきかわからなくなってしましいます。</p>
</blockquote>
<blockquote>
<p>ここのポイント</p>
<p>これは、impl で型とトレイトをくっつける時にお互いが外部の場合で、何かしらのプロジェクトに 10 個ほどクレートを呼び出して、
クレート１から１０までに同じ実装がある場合、コンパイラが「え？全部に同じ impl があるねんけど、どれ呼び出したらええん？」
みたいな感じで困惑するので、それを防ぎましょうね？と言うことですかね？
なのでそれを防ぐ方法として、型、トレイトのどちらか最低一つでも「独自」の定義した内容を盛り込みましょう！
みたいな認識だと思います。</p>
</blockquote>
<h4 id="デフォルト実装"><a class="header" href="#デフォルト実装">デフォルト実装</a></h4>
<p>時として、全ての型の全メソッドに対して実装を要求するのではなく、トレイトの全てあるいは一部のメソッドに対してデフォルトの振る舞いがあると有用です。 そうすれば、特定の型にトレイトを実装する際、各メソッドのデフォルト実装を保持するかオーバーライドするか選べるわけです。</p>
<p>リスト 10-14 は、リスト 10-12 のように、メソッドシグニチャだけを定義するのではなく、 Summary トレイトの summarize メソッドにデフォルトの文字列を指定する方法を示しています。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        // &quot;（もっと読む）&quot;
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">   pub headline: String,
</span><span class="boring">   pub location: String,
</span><span class="boring">   pub author: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">   pub username: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">   pub reply: bool,
</span><span class="boring">   pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">   fn summarize(&amp;self) -&gt; String {
</span><span class="boring">       format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>リスト 10-14: summarize メソッドのデフォルト実装がある Summary トレイトの定義</p>
<p>独自の実装を定義するのではなく、デフォルト実装を利用して NewsArticle のインスタンスをまとめるには、 impl Summary for NewsArticle {}と空の impl ブロックを指定します。</p>
<p>もはや NewsArticle に直接 summarize メソッドを定義してはいませんが、私達はデフォルト実装を提供しており、 NewsArticle は Summary トレイトを実装すると指定しました。そのため、 NewsArticle のインスタンスに対して summarize メソッドを同じように呼び出すことができます。 このように:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        // ペンギンチームがスタンレーカップチャンピオンシップを勝ち取る！
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        // アメリカ、ペンシルベニア州、ピッツバーグ
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        // アイスバーグ
        author: String::from(&quot;Iceburgh&quot;),
        // ピッツバーグ・ペンギンが再度NHL(National Hockey League)で最強のホッケーチームになった
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre></pre>
<p>このコードは、New article available! (Read more...)（新しい記事があります！（もっと読む））と出力します。</p>
<p>summarize にデフォルト実装を用意しても、リスト 10-13 の Tweet の Summary 実装を変える必要はありません。 理由は、デフォルト実装をオーバーライドする記法はデフォルト実装のないトレイトメソッドを実装する記法と同じだからです。</p>
<p>デフォルト実装は、自らのトレイトのデフォルト実装を持たない他のメソッドを呼び出すことができます。 このようにすれば、トレイトは多くの有用な機能を提供しつつ、実装者は僅かな部分しか指定しなくて済むようになります。 例えば、Summary トレイトを、（実装者が）内容を実装しなければならない summarize_author メソッドを持つように定義し、 それから summarize_author メソッドを呼び出すデフォルト実装を持つ summarize メソッドを定義することもできます:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
<span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        // &quot;（{}さんの文章をもっと読む）&quot;
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">   pub username: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">   pub reply: bool,
</span><span class="boring">   pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">   fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">       format!(&quot;@{}&quot;, self.username)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>このバージョンの Summary を使用するために、型にトレイトを実装する際、実装する必要があるのは summarize_author だけです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">   fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">   fn summarize(&amp;self) -&gt; String {
</span><span class="boring">       // &quot;（{}さんの文章をもっと読む）&quot;
</span><span class="boring">       format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">   pub username: String,
</span><span class="boring">   pub content: String,
</span><span class="boring">   pub reply: bool,
</span><span class="boring">   pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>summarize_author 定義後、Tweet 構造体のインスタンスに対して summarize を呼び出せ、 summarize のデフォルト実装は、私達が提供した summarize_author の定義を呼び出すでしょう。 summarize_author を実装したので、追加のコードを書く必要なく、Summary トレイトは、 summarize メソッドの振る舞いを与えてくれました。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre></pre>
<p>このコードは、1 new tweet: (Read more from @horse_ebooks...)（1 つの新しいツイート：（@horse_ebooks さんの文章をもっと読む））と出力します。</p>
<p>デフォルト実装を、そのメソッドをオーバーライドしている実装から呼び出すことはできないことに注意してください。</p>
<blockquote>
<p>感想</p>
<p>鬼難しい。デフォルト実装のポイントがさっぱりわからん。
とりあえず今のところわかっているのは、デフォルト実装という機能を使うと impl の時に宣言しなくてもいいことはわかった。
ただ何がデフォルト実装で、何がデフォルト実装ではないのか？の区別がつかない。</p>
</blockquote>
<p>トレイトは関数名と引数と返り値の型情報だけで構成される。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p>トレイトのデフォルト実装は関数名と引数と返り値の型情報と、関数の実行内容も記載されます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn summarize_author(&amp;self) -&gt; String; // トレイトの実装

pub trait Summary { // デフォルトトレイトの実装
    fn summarize(&amp;self) -&gt; String {
        // &quot;（もっと読む）&quot;
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>デフォルト実装はトレイトの定義時に処理も記載しているかどうかで判別します。</p>
</blockquote>
<h3 id="引数としてのトレイト"><a class="header" href="#引数としてのトレイト">引数としてのトレイト</a></h3>
<p>トレイトを定義し実装する方法はわかったので、
トレイトを使っていろんな種類の型を受け付ける関数を定義する方法を学んでいきましょう。</p>
<p>たとえば、Listing 10-13 では、NewsArticle と Tweet 型に Summary トレイトを実装しました。
ここで、引数の item の summarize メソッドを呼ぶ関数 notify を定義することができます。
ただし、引数 item は Summary トレイトを実装しているような何らかの型であるとします。
このようなことをするためには、impl Trait 構文を使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>引数の item には、具体的な型の代わりに、impl キーワードとトレイト名を指定します。
この引数は、指定されたトレイトを実装しているあらゆる型を受け付けます。
notify の中身では、summarize のような、Summary トレイトに由来する item のあらゆるメソッドを呼び出すことができます。
私達は、notify を呼びだし、NewsArticle か Tweet のどんなインスタンスでも渡すことができます。
この関数を呼び出すときに、String や i32 のような他の型を渡すようなコードはコンパイルできません。
なぜなら、これらの型は Summary を実装していないからです。</p>
<blockquote>
<p>引数に対してトレイトを実装することができて、引数にトレイトの振る舞いを付与することができるので、
実行内容にトレイトの振る舞いの関数を使用することができる。</p>
</blockquote>
<h4 id="トレイト境界構文"><a class="header" href="#トレイト境界構文">トレイト境界構文</a></h4>
<p>impl Trait 構文は単純なケースを解決しますが、実はより長いトレイト境界 (trait bound) と呼ばれる姿の糖衣構文 (syntax sugar) なのです。 それは以下のようなものです：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    // 速報！ {}
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>この「より長い」姿は前節の例と等価ですが、より冗長です。
山カッコの中にジェネリックな型引数の宣言を書き、型引数の後ろにコロンを挟んでトレイト境界を置いています。</p>
<p>簡単なケースに対し、impl Trait 構文は便利で、コードを簡潔にしてくれます。
そうでないケースの場合、トレイト境界構文を使えば複雑な状態を表現できます。
たとえば、Summary を実装する 2 つのパラメータを持つような関数を考えることができます。
impl Trait 構文を使うとこのようになるでしょう：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
<span class="boring">}
</span></code></pre></pre>
<p>この関数が受け取る item1 と item2 の型が（どちらも Summary を実装する限り）異なっても良いとするならば、
impl Trait は適切でしょう。
両方の引数が同じ型であることを強制することは、以下のようにトレイト境界を使ってのみ表現可能です：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
<span class="boring">}
</span></code></pre></pre>
<p>引数である item1 と item2 の型としてジェネリックな型 T を指定しました。
これにより、item1 と item2 として関数に渡される値の具体的な型が同一でなければならない、
という制約を与えています。</p>
<blockquote>
<p>ここはあくまでもトレイトを元々の表現方法であって、簡潔に実装できるようになっているので、原理ぐらいにとどめておくほうがいい。</p>
</blockquote>
<h4 id="複数のトレイト境界を構文で指定する"><a class="header" href="#複数のトレイト境界を構文で指定する">複数のトレイト境界を+構文で指定する</a></h4>
<p>複数のトレイト境界も指定できます。
たとえば、notify に summarize メソッドに加えて item の画面出力形式（ディスプレイフォーマット）を使わせたいとします。
その場合は、notify の定義に item は Display と Summary の両方を実装していなくてはならないと指定することになります。
これは、以下のように+構文で行うことができます：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;(impl Summary + Display)) {
<span class="boring">}
</span></code></pre></pre>
<p>+構文はジェネリック型につけたトレイト境界に対しても使えます：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
<span class="boring">}
</span></code></pre></pre>
<p>これら 2 つのトレイト境界が指定されていれば、notify の中では summarize を呼び出すことと、
{}を使って item をフォーマットすることの両方が行なえます。</p>
<h4 id="where-句を使ったより明確なトレイト境界"><a class="header" href="#where-句を使ったより明確なトレイト境界">where 句を使ったより明確なトレイト境界</a></h4>
<p>あまりたくさんのトレイト境界を使うことには欠点もあります。
それぞれのジェネリック（な型）がそれぞれのトレイト境界をもつので、
複数のジェネリック型の引数をもつ関数は、関数名と引数リストの間に大量のトレイト境界に関する情報を含むことがあります。
これでは関数のシグネチャが読みにくくなってしまいます。
このため、Rust はトレイト境界を関数シグネチャの後の where 句の中で指定するという別の構文を用意しています。 なので、このように書く：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
<span class="boring">}
</span></code></pre></pre>
<p>代わりに、where 句を使い、このように書くことができます：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
<span class="boring">}
</span></code></pre></pre>
<p>この関数シグニチャは、よりさっぱりとしています。
トレイト境界を多く持たない関数と同じように、関数名、引数リスト、戻り値の型が一緒になって近くにあるからですね。</p>
<blockquote>
<p>基本的に書きやすくするためにあるものと思っておけばいい。実際に使うときになったら考えましょう。</p>
</blockquote>
<h3 id="トレイトを実装している型を返す"><a class="header" href="#トレイトを実装している型を返す">トレイトを実装している型を返す</a></h3>
<p>以下のように、impl Trait 構文を戻り値型のところで使うことにより、あるトレイトを実装する何らかの型を返すことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>戻り値の型として impl Summary を使うことにより、具体的な型が何かを言うことなく、
returns_summarizable 関数は Summary トレイトを実装している何らかの型を返すのだ、と指定することができます。
今回 returns_summarizable は Tweet を返しますが、この関数を呼び出すコードはそのことを知りません。</p>
<p>実装しているトレイトだけで戻り値型を指定できることは、13 章で学ぶ、クロージャとイテレータを扱うときに特に便利です。
クロージャとイテレータの作り出す型は、コンパイラだけが知っているものであったり、指定するには長すぎるものであったりします。
impl Trait 構文を使えば、非常に長い型を書くことなく、ある関数は Iterator トレイトを実装するある型を返すのだ、
と簡潔に指定することができます。</p>
<p>ただし、impl Trait は一種類の型を返す場合にのみ使えます。
たとえば、以下のように、戻り値の型は impl Summary で指定しつつ、NewsArticle か Tweet を返すようなコードは失敗します：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>NewsArticle か Tweet を返すというのは、コンパイラの impl Trait 構文の実装まわりの制約により許されていません。
このような振る舞いをする関数を書く方法は、17 章のトレイトオブジェクトで異なる型の値を許容する節で学びます。</p>
<blockquote>
<p>返り値のトレイトは一種類だけ。条件によって if 文制御ができない</p>
</blockquote>
<h3 id="トレイト境界で-largest-関数を修正する"><a class="header" href="#トレイト境界で-largest-関数を修正する">トレイト境界で largest 関数を修正する</a></h3>
<p>ジェネリックな型引数の境界で使用したい振る舞いを指定する方法がわかったので、リスト 10-5 に戻って、
ジェネリックな型引数を使用する largest 関数の定義を修正しましょう！
最後にそのコードを実行しようとした時、 こんなエラーが出ていました:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>largest の本体で、大なり演算子(&gt;)を使用して型 T の 2 つの値を比較しようとしていました。
この演算子は、 標準ライブラリトレイトの std::cmp::PartialOrd でデフォルトメソッドとして定義されているので、
largest 関数が、比較できるあらゆる型のスライスに対して動くようにするためには、
T のトレイト境界に PartialOrd を指定する必要があります。
PartialOrd は prelude に含まれているので、これをスコープに導入する必要はありません。
largest のシグニチャを以下のように変えてください:</p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>今回のコンパイルでは、別のエラーが出てきます：</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
（エラー[E0508]： 型`[T]`をもつ、非コピーのスライスからのムーブはできません）
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       （ここからムーブすることはできません）
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       （ムーブが発生するのは、`list[_]`は`T`という、`Copy`トレイトを実装しない型であるためです）
  |                       help: consider borrowing here: `&amp;list[0]`
  |                       （助言：借用するようにしてみてはいかがですか： `&amp;list[0]`）

error[E0507]: cannot move out of a shared reference
（エラー[E0507]：共有の参照からムーブはできません）
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |（データがここでムーブされています）
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         |（ムーブが発生するのは、`item`は`T`という、`Copy`トレイトを実装しない型であるためです）
  |         help: consider removing the `&amp;`: `item`
  |         （助言：`&amp;`を取り除いてみてはいかがですか： `item`）

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>このエラーの鍵となる行は、cannot move out of type [T], a non-copy slice です。
ジェネリックでないバージョンの largest 関数では、最大の i32 か char を探そうとするだけでした。
第 4 章のスタックのみのデータ: コピー節で議論したように、i32 や char のようなサイズが既知の型はスタックに格納できるので、
Copy トレイトを実装しています。
しかし、largest 関数をジェネリックにすると、list 引数が Copy トレイトを実装しない型を含む可能性も出てきたのです。
結果として、list[0]から値を largest にムーブできず、このエラーに陥ったのです。</p>
<p>このコードを Copy トレイトを実装する型だけを使って呼び出すようにしたいなら、
T のトレイト境界に Copy を追加すればよいです！
リスト 10-15 は、関数に渡したスライスの値の型が、
i32 や char などのように PartialOrd と Copy を実装する限りコンパイルできる、
ジェネリックな largest 関数の完全なコードを示しています。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>リスト 10-15: PartialOrd と Copy トレイトを実装するあらゆるジェネリックな型に対して動く、 largest 関数の実際の定義</p>
<p>もし largest 関数を Copy を実装する型だけに制限したくなかったら、
T が Copy ではなく Clone というトレイト境界を持つと指定することもできます。
そうしたら、 largest 関数に所有権が欲しい時にスライスの各値をクローンできます。
clone 関数を使用するということは、
String のようなヒープデータを持つ型の場合により多くのヒープ確保が発生する可能性があることを意味します。
そして、大量のデータを取り扱っていたら、ヒープ確保には時間がかかることもあります。</p>
<p>largest の別の実装方法は、関数がスライスの T 値への参照を返すようにすることです。
戻り値の型を T ではなく&amp;T に変え、それにより関数の本体を参照を返すように変更したら、
Clone や Copy トレイト境界は必要なくなり、ヒープ確保も避けられるでしょう。 これらの代替策をご自身で実装してみましょう！</p>
<h3 id="トレイト境界を使用してメソッド実装を条件分けする"><a class="header" href="#トレイト境界を使用してメソッド実装を条件分けする">トレイト境界を使用して、メソッド実装を条件分けする</a></h3>
<p>ジェネリックな型引数を持つ impl ブロックにトレイト境界を与えることで、 特定のトレイトを実装する型に対するメソッド実装を条件分けできます。例えば、 リスト 10-16 の型 Pair<T>は、常に new 関数を実装します。しかし、Pair<T>は、 内部の型 T が比較を可能にする PartialOrd トレイトと出力を可能にする Display トレイトを実装している時のみ、 cmp_display メソッドを実装します。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
}
</code></pre></pre>
<p>リスト 10-16: トレイト境界によってジェネリックな型に対するメソッド実装を条件分けする</p>
<p>また、別のトレイトを実装するあらゆる型に対するトレイト実装を条件分けすることもできます。 トレイト境界を満たすあらゆる型にトレイトを実装することは、ブランケット実装(blanket implementation)と呼ばれ、 Rust の標準ライブラリで広く使用されています。例を挙げれば、標準ライブラリは、 Display トレイトを実装するあらゆる型に ToString トレイトを実装しています。 標準ライブラリの impl ブロックは以下のような見た目です:</p>
<pre><code>impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>標準ライブラリにはこのブランケット実装があるので、Display トレイトを実装する任意の型に対して、 ToString トレイトで定義された to_string メソッドを呼び出せるのです。 例えば、整数は Display を実装するので、このように整数値を対応する String 値に変換できます:</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
let s = 3.to_string();
}
</code></pre></pre>
<p>ブランケット実装は、トレイトのドキュメンテーションの「実装したもの」節に出現します。</p>
<p>トレイトとトレイト境界により、ジェネリックな型引数を使用して重複を減らしつつ、コンパイラに対して、 そのジェネリックな型に特定の振る舞いが欲しいことを指定するコードを書くことができます。 それからコンパイラは、トレイト境界の情報を活用してコードに使用された具体的な型が正しい振る舞いを提供しているか確認できます。 動的型付き言語では、その型に定義されていないメソッドを呼び出せば、実行時 (runtime) にエラーが出るでしょう。 しかし、Rust はこの種のエラーをコンパイル時に移したので、コードが動かせるようになる以前に問題を修正することを強制されるのです。 加えて、コンパイル時に既に確認したので、実行時の振る舞いを確認するコードを書かなくても済みます。 そうすることで、ジェネリクスの柔軟性を諦めることなくパフォーマンスを向上させます。</p>
<p>すでに使っている他のジェネリクスに、ライフタイムと呼ばれるものがあります。 ライフタイムは、型が欲しい振る舞いを保持していることではなく、必要な間だけ参照が有効であることを保証します。 ライフタイムがどうやってそれを行うかを見てみましょう。</p>
<blockquote>
<p>ひとまずトレイトのイメージが今は掴めました。
次はライフタイムです。</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ライフタイムで参照を検証する"><a class="header" href="#ライフタイムで参照を検証する">ライフタイムで参照を検証する</a></h1>
<p>第4章の「参照と借用」節で議論しなかった詳細の一つに、Rustにおいて参照は全てライフタイムを保持するということがあります。 ライフタイムとは、その参照が有効になるスコープのことです。多くの場合、型が推論されるように、 大体の場合、ライフタイムも暗黙的に推論されます。複数の型の可能性があるときには、型を注釈しなければなりません。 同様に、参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈しなければなりません。 コンパイラは、ジェネリックライフタイム引数を使用して関係を注釈し、実行時に実際の参照が確かに有効であることを保証することを要求するのです。</p>
<p>ライフタイムの概念は、他のプログラミング言語の道具とはどこか異なり、間違いなくRustで一番際立った機能になっています。 この章では、ライフタイムの全体を解説することはしませんが、 ライフタイム記法が必要となる最も一般的な場合について議論しますので、ライフタイムの概念について馴染むことができるでしょう。</p>
<h2 id="ライフタイムでダングリング参照を回避する"><a class="header" href="#ライフタイムでダングリング参照を回避する">ライフタイムでダングリング参照を回避する</a></h2>
<p>ライフタイムの主な目的は、ダングリング参照を回避することです。ダングリング参照によりプログラムは、 参照するつもりだったデータ以外のデータを参照してしまいます。リスト10-17のプログラムを考えてください。 これには、外側のスコープと内側のスコープが含まれています。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
}
</code></pre></pre>
<p>リスト10-17: 値がスコープを抜けてしまった参照を使用しようとする</p>
<blockquote>
<p>注釈: リスト10-17や10-18、10-24では、変数に初期値を与えずに宣言しているので、変数名は外側のスコープに存在します。 初見では、これはRustにはnull値が存在しないということと衝突しているように見えるかもしれません。 しかしながら、値を与える前に変数を使用しようとすれば、コンパイルエラーになり、 確かにRustではnull値は許可されていないことがわかります。</p>
</blockquote>
<p>外側のスコープで初期値なしのrという変数を宣言し、内側のスコープで初期値5のxという変数を宣言しています。 内側のスコープ内で、rの値をxへの参照にセットしようとしています。それから内側のスコープが終わり、 rの値を出力しようとしています。rが参照している値が使おうとする前にスコープを抜けるので、 このコードはコンパイルできません。こちらがエラーメッセージです:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
（エラー[E0597]: `x`の生存期間が短すぎます）
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
   |                   (借用された値の生存期間が短すぎます)
8  |         }
   |         - `x` dropped here while still borrowed
   |          (`x`は借用されている間にここでドロップされました)
9  |
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here
   |                            (その後、借用はここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>変数xの「生存期間が短すぎます」。原因は、内側のスコープが7行目で終わった時点でxがスコープを抜けるからです。 ですが、rはまだ、外側のスコープに対して有効です; スコープが大きいので、「長生きする」と言います。 Rustで、このコードが動くことを許可していたら、rはxがスコープを抜けた時に解放されるメモリを参照していることになり、 rで行おうとするいかなることもちゃんと動作しないでしょう。では、どうやってコンパイラはこのコードが無効であると決定しているのでしょうか？ それは、借用チェッカーを使用しているのです。</p>
<h2 id="借用精査機"><a class="header" href="#借用精査機">借用精査機</a></h2>
<p>Rustコンパイラには、スコープを比較して全ての借用が有効であるかを決定する借用チェッカーがあります。 リスト10-18は、リスト10-17と同じコードを示していますが、変数のライフタイムを表示する注釈が付いています。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
}

</code></pre></pre>
<p>リスト10-18: それぞれ'aと'bと名付けられたrとxのライフタイムの注釈</p>
<p>ここで、rのライフタイムは'a、xのライフタイムは'bで注釈しました。ご覧の通り、 内側の'bブロックの方が、外側の'aライフタイムブロックよりはるかに小さいです。 コンパイル時に、コンパイラは2つのライフタイムのサイズを比較し、rは'aのライフタイムだけれども、 'bのライフタイムのメモリを参照していると確認します。'bは'aよりも短いので、プログラムは拒否されます: 参照の対象が参照ほど長生きしないのです。</p>
<p>リスト10-19でコードを修正したので、ダングリング参照はなくなり、エラーなくコンパイルできます。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
}
</code></pre></pre>
<p>リスト10-19: データのライフタイムが参照より長いので、有効な参照</p>
<p>ここでxのライフタイムは'bになり、今回の場合'aよりも大きいです。つまり、 コンパイラはxが有効な間、rの参照も常に有効になることを把握しているので、rはxを参照できます。</p>
<p>今や、参照のライフタイムがどれだけであるかと、コンパイラがライフタイムを解析して参照が常に有効であることを保証する仕組みがわかったので、 関数における引数と戻り値のジェネリックなライフタイムを探究しましょう。</p>
<h2 id="関数のジェネリックなライフタイム"><a class="header" href="#関数のジェネリックなライフタイム">関数のジェネリックなライフタイム</a></h2>
<p>2つの文字列スライスのうち、長い方を返す関数を書きましょう。この関数は、 2つの文字列スライスを引数に取り、1つの文字列スライスを返します。longest関数の実装完了後、 リスト10-20のコードは、The longest string is abcdと出力するはずです。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    // 最長の文字列は、{}です
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre></pre>
<p>リスト10-20: longest関数を呼び出して2つの文字列スライスのうち長い方を探すmain関数</p>
<p>関数に取ってほしい引数が文字列スライス、つまり参照であることに注意してください(&amp;変数名の形)。 何故なら、longest関数に引数の所有権を奪ってほしくないからです。 リスト10-20で使用している引数が、我々が必要としているものである理由についてもっと詳しい議論は、 第4章の「引数としての文字列スライス」節をご参照ください。</p>
<p>リスト10-21に示すようにlongest関数を実装しようとしたら、コンパイルできないでしょう。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-21: 2つの文字列スライスのうち長い方を返すけれども、コンパイルできないlongest関数の実装</p>
<p>代わりに、以下のようなライフタイムに言及するエラーが出ます:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
(エラー[E0106]: ライフタイム指定子が不足しています)
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |                                   (ライフタイム引数があるべきです)
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
  (助言: この関数の戻り値型は借用された値を含んでいますが、
   シグニチャは、それが`x`と`y`どちらから借用されたものなのか宣言していません)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>助言テキストが、戻り値の型はジェネリックなライフタイム引数である必要があると明かしています。 というのも、返している参照がxかyのどちらを参照しているか、コンパイラにはわからないからです。 実際のところ、この関数の本体のifブロックはxへの参照を返し、elseブロックはyへの参照を返すので、 どちらなのか私たちにもわかりません！</p>
<p>この関数を定義する際、この関数に渡される具体的な値がわからないので、ifケースとelseケースのどちらが実行されるかわからないのです。 また、リスト10-18と10-19で、返す参照が常に有効であるかを決定したときのようにスコープを見ることも、渡される参照の具体的なライフタイムがわからないのでできないのです。 借用チェッカーもこれを決定することはできません。xとyのライフタイムがどう戻り値のライフタイムと関係するかわからないからです。 このエラーを修正するために、借用チェッカーが解析を実行できるように、参照間の関係を定義するジェネリックなライフタイム引数を追加しましょう。</p>
<h2 id="ライフタイム注釈記法"><a class="header" href="#ライフタイム注釈記法">ライフタイム注釈記法</a></h2>
<p>ライフタイム注釈は、いかなる参照の生存期間も変えることはありません。シグニチャにジェネリックな型引数を指定された 関数が、あらゆる型を受け取ることができるのと同様に、ジェネリックなライフタイム引数を指定された関数は、 あらゆるライフタイムの参照を受け取ることができます。ライフタイム注釈は、ライフタイムに影響することなく、 複数の参照のライフタイムのお互いの関係を記述します。</p>
<p>ライフタイム注釈は、少し不自然な記法です: ライフタイム引数の名前はアポストロフィー(')で始まらなければならず、 通常全部小文字で、ジェネリック型のようにとても短いです。多くの人は、'aという名前を使います。 ライフタイム引数注釈は、参照の&amp;の後に配置し、注釈と参照の型を区別するために空白を1つ使用します。</p>
<p>例を挙げましょう: ライフタイム引数なしのi32への参照、'aというライフタイム引数付きのi32への参照、 そして同じくライフタイム'aを持つi32への可変参照です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;i32        // a reference
            // (ただの)参照
&amp;'a i32     // a reference with an explicit lifetime
            // 明示的なライフタイム付きの参照
&amp;'a mut i32 // a mutable reference with an explicit lifetime
            // 明示的なライフタイム付きの可変参照
<span class="boring">}
</span></code></pre></pre>
<p>1つのライフタイム注釈それだけでは、大して意味はありません。注釈は、複数の参照のジェネリックなライフタイム引数が、 お互いにどう関係するかをコンパイラに指示することを意図しているからです。例えば、 ライフタイム'a付きのi32への参照となる引数firstのある関数があるとしましょう。 この関数にはさらに、'aのライフタイム付きのi32への別の参照となるsecondという別の引数もあります。 ライフタイム注釈は、firstとsecondの参照がどちらもこのジェネリックなライフタイムと同じだけ生きることを示唆します。</p>
<h2 id="関数シグニチャにおけるライフタイム注釈"><a class="header" href="#関数シグニチャにおけるライフタイム注釈">関数シグニチャにおけるライフタイム注釈</a></h2>
<p>さて、longest関数を例にライフタイム注釈を詳しく見ていきましょう。ジェネリックな型引数同様、 関数名と引数リストの間の山カッコの中にジェネリックなライフタイム引数を宣言します。 このシグニチャで表現したい制約は、引数の全ての参照と戻り値が同じライフタイムを持つことです。 リスト10-22に示すように、ライフタイムを'aと名付け、それを各参照に付与します。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-22: シグニチャの全参照が同じライフタイム'aを持つと指定したlongest関数の定義</p>
<p>このコードはコンパイルでき、リスト10-20のmain関数とともに使用したら、欲しい結果になるはずです。</p>
<p>これで関数シグニチャは、何らかのライフタイム'aに対して、関数は2つの引数を取り、 どちらも少なくともライフタイム'aと同じだけ生きる文字列スライスであるとコンパイラに教えるようになりました。 また、この関数シグニチャは、関数から返る文字列スライスも少なくともライフタイム'aと同じだけ生きると、 コンパイラに教えています。 実際には、longest関数が返す参照のライフタイムは、渡された参照のうち、小さい方のライフタイムと同じであるという事です。 これらの制約は、まさに私たちがコンパイラに保証してほしかったものです。</p>
<p>この関数シグニチャでライフタイム引数を指定する時、渡されたり、返したりした、いかなる値のライフタイムも変更していないことを思い出してください。 むしろ、借用チェッカーは、これらの制約を守らない値全てを拒否するべきと指定しています。 longest関数は、xとyの正確な生存期間を知っている必要はなく、 このシグニチャを満たすようなスコープを'aに代入できることを知っているだけであることに注意してください。</p>
<p>関数にライフタイムを注釈するときは、注釈は関数の本体ではなくシグニチャに付与します。 コンパイラは注釈がなくとも関数内のコードを解析できます。しかしながら、 関数に関数外からの参照や関数外への参照がある場合、コンパイラが引数や戻り値のライフタイムを自力で解決することはほとんど不可能になります。 そのライフタイムは、関数が呼び出される度に異なる可能性があります。このために、手動でライフタイムを注釈する必要があるのです。</p>
<p>具体的な参照をlongestに渡すと、'aに代入される具体的なライフタイムは、xのスコープの一部であってyのスコープと重なる部分となります。 言い換えると、ジェネリックなライフタイム'aは、xとyのライフタイムのうち、小さい方に等しい具体的なライフタイムになるのです。 返却される参照を同じライフタイム引数'aで注釈したので、返却される参照もxかyのライフタイムの小さい方と同じだけ有効になるでしょう。</p>
<p>ライフタイム注釈が異なる具体的なライフタイムを持つ参照を渡すことでlongest関数を制限する方法を見ましょう。 リスト10-23はそのシンプルな例です。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 長い文字列は長い
    let string1 = String::from(&quot;long string is long&quot;);
    // （訳注：この言葉自体に深い意味はない。下の&quot;xyz&quot;より長いということだけが重要）

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        // 一番長い文字列は{}
        println!(&quot;The longest string is {}&quot;, result);
    }
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-23: 異なる具体的なライフタイムを持つString値への参照でlongest関数を使用する</p>
<p>この例において、string1は外側のスコープの終わりまで有効で、string2は内側のスコープの終わりまで有効、 そしてresultは内側のスコープの終わりまで有効な何かを参照しています。このコードを実行すると、 借用チェッカーがこのコードを良しとするのがわかるでしょう。要するに、コンパイルでき、 The longest string is long string is longと出力するのです。</p>
<p>次に、resultの参照のライフタイムが2つの引数の小さい方のライフタイムになることを示す例を試しましょう。 result変数の宣言を内側のスコープの外に移すものの、result変数への代入はstring2のスコープ内に残したままにします。 それからresultを使用するprintln!を内側のスコープの外、内側のスコープが終わった後に移動します。 リスト10-24のコードはコンパイルできません。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>リスト10-24: string2がスコープを抜けてからresultを使用しようとする</p>
<p>このコードのコンパイルを試みると、こんなエラーになります:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>このエラーは、resultがprintln!文に対して有効であるためには、string2が外側のスコープの終わりまで有効である必要があることを示しています。 関数引数と戻り値のライフタイムを同じライフタイム引数'aで注釈したので、コンパイラはこのことを知っています。</p>
<p>人間からしたら、string1はstring2よりも長く、それ故にresultがstring1への参照を含んでいることは コードから明らかです。まだstring1はスコープを抜けていないので、 string1への参照はprintln!にとって有効でしょう。ですが、コンパイラはこの場合、 参照が有効であると見なせません。longest関数から返ってくる参照のライフタイムは、 渡した参照のうちの小さい方と同じだとコンパイラに指示しました。したがって、 借用チェッカーは、リスト10-24のコードを無効な参照がある可能性があるとして許可しないのです。</p>
<p>試しに、値や、longest関数に渡される参照のライフタイムや、返される参照の使われかたが異なる実験をもっとしてみてください。 コンパイル前に、その実験が借用チェッカーを通るかどうか仮説を立ててください; そして、正しいか確かめてください！</p>
<h2 id="ライフタイムの観点で思考する"><a class="header" href="#ライフタイムの観点で思考する">ライフタイムの観点で思考する</a></h2>
<p>何にライフタイム引数を指定する必要があるかは、関数が行っていることに依存します。例えば、 longest関数の実装を最長の文字列スライスではなく、常に最初の引数を返すように変更したら、 y引数に対してライフタイムを指定する必要はなくなるでしょう。以下のコードはコンパイルできます:</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>この例では、引数xと戻り値に対してライフタイム引数'aを指定しましたが、引数yには指定していません。 yのライフタイムはxや戻り値のライフタイムとは何の関係もないからです。</p>
<p>関数から参照を返す際、戻り値型のライフタイム引数は、引数のうちどれかのライフタイム引数と一致する必要があります。 返される参照が引数のどれかを参照していないならば、この関数内で生成された値を参照しているはずです。 すると、その値は関数の末端でスコープを抜けるので、これはダングリング参照になるでしょう。 以下に示す、コンパイルできないlongest関数の未完成の実装を考えてください:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    // 本当に長い文字列
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre></pre>
<blockquote>
<p>ライフタイム引数が関係ないので、何の意味があるのか？となるます</p>
</blockquote>
<p>ここでは、たとえ、戻り値型にライフタイム引数'aを指定していても、戻り値のライフタイムは、 引数のライフタイムと全く関係がないので、この実装はコンパイルできないでしょう。 こちらが、得られるエラーメッセージです:</p>
<pre><code>$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
(エラー[E0515]: ローカル変数`result`を参照している値は返せません)
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here
   |    (現在の関数に所有されているデータを参照する値を返しています
   |     `result`はここで借用されています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>問題は、resultがlongest関数の末端でスコープを抜け、片付けられてしまうことです。 かつ、関数からresultへの参照を返そうともしています。ダングリング参照を変えてくれるようなライフタイム引数を指定する手段はなく、 コンパイラは、ダングリング参照を生成させてくれません。今回の場合、最善の修正案は、 （呼び出し先ではなく）呼び出し元の関数に値の片付けをさせるために、参照ではなく所有されたデータ型を返すことでしょう。</p>
<p>究極的にライフタイム記法は、関数のいろんな引数と戻り値のライフタイムを接続することに関するものです。 一旦それらが繋がれば、メモリ安全な処理を許可し、ダングリングポインタを生成したりメモリ安全性を侵害したりする処理を禁止するのに十分な情報をコンパイラは得たことになります。</p>
<h2 id="構造体定義のライフタイム注釈"><a class="header" href="#構造体定義のライフタイム注釈">構造体定義のライフタイム注釈</a></h2>
<p>ここまで、所有された型を保持する構造体だけを定義してきました。構造体に参照を保持させることもできますが、 その場合、構造体定義の全参照にライフタイム注釈を付け加える必要があるでしょう。 リスト10-25には、文字列スライスを保持するImportantExcerpt(重要な一節)という構造体があります。</p>
<p>ファイル名: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    // 僕をイシュマエルとお呼び。何年か前・・・
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    //                                                  &quot;'.'が見つかりませんでした&quot;
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p>リスト10-25: 参照を含む構造体なので、定義にライフタイム注釈が必要</p>
<p>この構造体には文字列スライスを保持する1つのフィールド、partがあり、これは参照です。 ジェネリックなデータ型同様、構造体名の後、山カッコの中にジェネリックなライフタイム引数の名前を宣言するので、 構造体定義の本体でライフタイム引数を使用できます。この注釈は、ImportantExcerptのインスタンスが、 partフィールドに保持している参照よりも長生きしないことを意味します。</p>
<p>ここのmain関数は、変数novelに所有されるStringの、最初の文への参照を保持するImportantExcerptインスタンスを生成しています。 novelのデータは、ImportantExcerptインスタンスが作られる前に存在しています。 加えて、ImportantExcerptがスコープを抜けるまでnovelはスコープを抜けないので、 ImportantExcerptインスタンスの参照は有効なのです。</p>
<h2 id="ライフタイム省略"><a class="header" href="#ライフタイム省略">ライフタイム省略</a></h2>
<p>全参照にはライフタイムがあり、参照を使用する関数や構造体にはライフタイム引数を指定する必要があることを学びました。 しかし、リスト4-9にあった関数（リスト10-26に再度示しました）はライフタイム注釈なしでコンパイルできました。</p>
<p>ファイル名: src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word works on slices of `String`s
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word works on slices of string literals
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<p>リスト10-26: リスト4-9で定義した、引数と戻り値型が参照であるにも関わらず、ライフタイム注釈なしでコンパイルできた関数</p>
<p>この関数がライフタイム注釈なしでコンパイルできる理由には、Rustの歴史が関わっています: 昔のバージョンのRust(1.0以前)では、 全参照に明示的なライフタイムが必要だったので、このコードはコンパイルできませんでした。 その頃、関数シグニチャはこのように記述されていたのです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
<span class="boring">}
</span></code></pre></pre>
<p>多くのRustコードを書いた後、Rustチームは、Rustプログラマが、 特定の場面で何度も同じライフタイム注釈を入力していることを発見しました。これらの場面は予測可能で、 いくつかの決まりきったパターンに従っていました。開発者はこのパターンをコンパイラのコードに落とし込んだので、 このような場面には借用チェッカーがライフタイムを推論できるようになり、明示的な注釈を必要としなくなったのです。</p>
<p>ここで、このRustの歴史話が関係しているのは、他にも決まりきったパターンが出現し、コンパイラに追加されることもあり得るからです。 将来的に、さらに少数のライフタイム注釈しか必要にならない可能性もあります。</p>
<p>コンパイラの参照解析に落とし込まれたパターンは、ライフタイム省略規則と呼ばれます。 これらはプログラマが従う規則ではありません; コンパイラが考慮する一連の特定のケースであり、 自分のコードがこのケースに当てはまれば、ライフタイムを明示的に書く必要はなくなります。</p>
<p>省略規則は、完全な推論を提供しません。コンパイラが決定的に規則を適用できるけれども、 参照が保持するライフタイムに関してそれでも曖昧性があるなら、コンパイラは、残りの参照がなるべきライフタイムを推測しません。 この場合コンパイラは、それらを推測するのではなくエラーを与えます。 これらは、参照がお互いにどう関係するかを指定するライフタイム注釈を追記することで解決できます。</p>
<p>関数やメソッドの引数のライフタイムは、入力ライフタイムと呼ばれ、 戻り値のライフタイムは出力ライフタイムと称されます。</p>
<p>コンパイラは3つの規則を活用し、明示的な注釈がない時に、参照がどんなライフタイムになるかを計算します。 最初の規則は入力ライフタイムに適用され、2番目と3番目の規則は出力ライフタイムに適用されます。 コンパイラが3つの規則の最後まで到達し、それでもライフタイムを割り出せない参照があったら、 コンパイラはエラーで停止します。 これらのルールはfnの定義にもimplブロックにも適用されます。</p>
<p>最初の規則は、参照である各引数は、独自のライフタイム引数を得るというものです。換言すれば、 1引数の関数は、1つのライフタイム引数を得るということです: fn foo&lt;'a&gt;(x: &amp;'a i32); 2つ引数のある関数は、2つの個別のライフタイム引数を得ます: fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32); 以下同様。</p>
<p>2番目の規則は、1つだけ入力ライフタイム引数があるなら、そのライフタイムが全ての出力ライフタイム引数に代入されるというものです: fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32。</p>
<p>3番目の規則は、複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが&amp;selfや&amp;mut selfだったら、 selfのライフタイムが全出力ライフタイム引数に代入されるというものです。 この3番目の規則により、必要なシンボルの数が減るので、メソッドが遥かに読み書きしやすくなります。</p>
<p>コンパイラの立場になってみましょう。これらの規則を適用して、リスト10-26のfirst_word関数のシグニチャの参照のライフタイムが何か計算します。 シグニチャは、参照に紐づけられるライフタイムがない状態から始まります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>そうして、コンパイラは最初の規則を適用し、各引数が独自のライフタイムを得ると指定します。 それを通常通り'aと呼ぶので、シグニチャはこうなります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>1つだけ入力ライフタイムがあるので、2番目の規則を適用します。2番目の規則は、1つの入力引数のライフタイムが、 出力引数に代入されると指定するので、シグニチャはこうなります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
<span class="boring">}
</span></code></pre></pre>
<p>もうこの関数シグニチャの全ての参照にライフタイムが付いたので、コンパイラは、 プログラマにこの関数シグニチャのライフタイムを注釈してもらう必要なく、解析を続行できます。</p>
<p>別の例に目を向けましょう。今回は、リスト10-21で取り掛かったときにはライフタイム引数がなかったlongest関数です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>最初の規則を適用しましょう: 各引数が独自のライフタイムを得るのです。今回は、 1つではなく2つ引数があるので、ライフタイムも2つです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
<span class="boring">}
</span></code></pre></pre>
<p>2つ以上入力ライフタイムがあるので、2番目の規則は適用されないとわかります。また3番目の規則も適用されません。 longestはメソッドではなく関数なので、どの引数もselfではないのです。3つの規則全部を適用した後でも、 まだ戻り値型のライフタイムが判明していません。このために、リスト10-21でこのコードをコンパイルしようとしてエラーになったのです: コンパイラは、ライフタイム省略規則全てを適用したけれども、シグニチャの参照全部のライフタイムを計算できなかったのです。</p>
<p>実際のところ、3番目の規則はメソッドのシグニチャにしか適用されません。ですので、次はその文脈においてライフタイムを観察し、 3番目の規則のおかげで、メソッドシグニチャであまり頻繁にライフタイムを注釈しなくても済む理由を確認します。</p>
<h2 id="メソッド定義におけるライフタイム注釈"><a class="header" href="#メソッド定義におけるライフタイム注釈">メソッド定義におけるライフタイム注釈</a></h2>
<p>構造体にライフタイムのあるメソッドを実装する際、リスト10-11で示したジェネリックな型引数と同じ記法を使用します。 ライフタイム引数を宣言し使用する場所は、構造体フィールドかメソッド引数と戻り値に関係するかによります。</p>
<p>構造体のフィールド用のライフタイム名は、implキーワードの後に宣言する必要があり、 それから構造体名の後に使用されます。そのようなライフタイムは構造体の型の一部になるからです。</p>
<p>implブロック内のメソッドシグニチャでは、参照は構造体のフィールドの参照のライフタイムに紐づいている可能性と、 独立している可能性があります。加えて、ライフタイム省略規則により、メソッドシグニチャでライフタイム注釈が必要なくなることがよくあります。 リスト10-25で定義したImportantExcerptという構造体を使用した例をいくつか見てみましょう。</p>
<p>まず、唯一の引数がselfへの参照で戻り値がi32という何かへの参照ではないlevelというメソッドを使用します:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">       //       &quot;お知らせします: {}&quot;
</span><span class="boring">       println!(&quot;Attention please: {}&quot;, announcement);
</span><span class="boring">       self.part
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">   let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">   let i = ImportantExcerpt {
</span><span class="boring">       part: first_sentence,
</span><span class="boring">   };
</span><span class="boring">}
</span></code></pre></pre>
<p>impl後のライフタイム引数宣言と型名の後にそれを使用するのは必須ですが、最初の省略規則のため、 selfへの参照のライフタイムを注釈する必要はありません。</p>
<p>3番目のライフタイム省略規則が適用される例はこちらです:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">   fn level(&amp;self) -&gt; i32 {
</span><span class="boring">       3
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        //       &quot;お知らせします: {}&quot;
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">   let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">   let i = ImportantExcerpt {
</span><span class="boring">       part: first_sentence,
</span><span class="boring">   };
</span><span class="boring">}
</span></code></pre></pre>
<p>2つ入力ライフタイムがあるので、コンパイラは最初のライフタイム省略規則を適用し、 &amp;selfとannouncementに独自のライフタイムを与えます。それから、 引数の1つが&amp;selfなので、戻り値型は&amp;selfのライフタイムを得て、 全てのライフタイムが説明されました。</p>
<h2 id="静的ライフタイム"><a class="header" href="#静的ライフタイム">静的ライフタイム</a></h2>
<p>議論する必要のある1種の特殊なライフタイムが、'staticであり、これは、この参照がプログラムの全期間生存できる事を意味します。 文字列リテラルは全て'staticライフタイムになり、次のように注釈できます:</p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
// 僕は静的ライフタイムを持ってるよ
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
}
</code></pre></pre>
<p>この文字列のテキストは、プログラムのバイナリに直接格納され、常に利用可能です。故に、全文字列リテラルのライフタイムは、 'staticなのです。</p>
<p>エラーメッセージで、'staticライフタイムを使用するよう勧める提言を見かける可能性があります。 ですが、参照に対してライフタイムとして'staticを指定する前に、今ある参照が本当にプログラムの全期間生きるかどうか考えてください。 それが可能であったとしても、参照がそれだけの期間生きてほしいのかどうか考慮するのも良いでしょう。 ほとんどの場合、問題は、ダングリング参照を生成しようとしているか、利用可能なライフタイムの不一致が原因です。 そのような場合、解決策はその問題を修正することであり、'staticライフタイムを指定することではありません。</p>
<h1 id="ジェネリックな型引数トレイト境界ライフタイムを一度に"><a class="header" href="#ジェネリックな型引数トレイト境界ライフタイムを一度に">ジェネリックな型引数、トレイト境界、ライフタイムを一度に</a></h1>
<p>ジェネリックな型引数、トレイト境界、ライフタイム指定の構文のすべてを1つの関数で簡単に見てみましょう！</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        &quot;Today is someone's birthday!&quot;,
    );
    println!(&quot;The longest string is {}&quot;, result);
}

use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    //       &quot;アナウンス！ {}&quot;
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>これがリスト10-22からの2つの文字列のうち長い方を返すlongest関数ですが、 ジェネリックな型Tのannという追加の引数があり、これはwhere節で指定されているように、 Displayトレイトを実装するあらゆる型で埋めることができます。 この追加の引数は、関数が文字列スライスの長さを比較する前に出力されるので、 Displayトレイト境界が必要なのです。ライフタイムは一種のジェネリックなので、 ライフタイム引数'aとジェネリックな型引数Tが関数名の後、山カッコ内の同じリストに収まっています。</p>
<h1 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h1>
<p>たくさんのことをこの章では講義しましたね！今やジェネリックな型引数、トレイトとトレイト境界、そしてジェネリックなライフタイム引数を知ったので、 多くの異なる場面で動くコードを繰り返すことなく書く準備ができました。ジェネリックな型引数により、 コードを異なる型に適用させてくれます。トレイトとトレイト境界は、型がジェネリックであっても、 コードが必要とする振る舞いを持つことを保証します。ライフタイム注釈を活用して、 この柔軟なコードにダングリング参照が存在しないことを保証する方法を学びました。 さらにこの解析は全てコンパイル時に起こり、実行時のパフォーマンスには影響しません！</p>
<p>信じられないかもしれませんが、この章で議論した話題にはもっともっと学ぶべきことがあります: 第17章ではトレイトオブジェクトを議論します。これはトレイトを使用する別の手段です。 非常に高度な筋書きの場合でのみ必要になる、ライフタイム注釈が関わる、もっと複雑な筋書きもあります。 それらについては、Rust Referenceをお読みください。 ですが次は、コードがあるべき通りに動いていることを確かめられるように、Rustでテストを書く方法を学びます。</p>
<blockquote>
<p>ライフタイムはダングリング参照を防ぐため、そういったエラーを無くすためというところからスタートする。</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="自動テストを書く"><a class="header" href="#自動テストを書く">自動テストを書く</a></h1>
<p>1972年のエッセイ「謙虚なプログラマ」でエドガー・W・ダイクストラは以下のように述べています。 「プログラムのテストは、バグの存在を示すには非常に効率的な手法であるが、 バグの不在を示すには望み薄く不適切である」と。これは、できるだけテストを試みるべきではないということではありません。</p>
<p>プログラムの正当性は、どこまで自分のコードが意図していることをしているかなのです。 Rustは、プログラムの正当性に重きを置いて設計されていますが、 正当性は複雑で、単純に証明することはありません。Rustの型システムは、 この重荷の多くの部分を肩代わりしてくれますが、型システムはあらゆる種類の不当性を捕捉してはくれません。 ゆえに、Rustでは、言語内で自動化されたソフトウェアテストを書くことをサポートしているのです。</p>
<p>例として、渡された何かの数値に2を足すadd_twoという関数を書くとしましょう。 この関数のシグニチャは、引数に整数を取り、結果として整数を返します。 この関数を実装してコンパイルすると、コンパイラはこれまでに学んできた型チェックと借用チェックを全て行い、 例えば、Stringの値や無効な参照をこの関数に渡していないかなどを確かめるのです。 ところが、コンパイラはプログラマがまさしく意図したことを関数が実行しているかどうかは確かめられません。 つまり、そうですね、引数に10を足したり、50を引いたりするのではなく、引数に2を足していることです。 そんな時に、テストは必要になるのです。</p>
<p>例えば、add_two関数に3を渡した時に、戻り値は5であることをアサーションするようなテストを書くことができます。 コードに変更を加えた際にこれらのテストを走らせ、既存の正当な振る舞いが変わっていないことを確認できます。</p>
<p>テストは、複雑なスキルです: いいテストの書き方をあらゆる方面から講義することは1章だけではできないのですが、 Rustのテスト機構のメカニズムについて議論します。テストを書く際に利用可能になるアノテーションとマクロについて、 テストを実行するのに提供されているオプションと標準の動作、さらにテストをユニットテストや統合テストに体系化する方法について語ります。</p>
<blockquote>
<p>テストは自分の想定したことをテストできるかをどのように表現することが大事であって、想定できないことはテストできません。（想定できるミスは防ぎましょうという意味合いが強いです。想定できないものはテストすらできないので）
テスト駆動開発系のエンジニアは非常に攻撃的な方も多いので注意することが不可欠です。自分のペースでかつ確実に実力をつけていきましょう。</p>
<p>テストコードの記述には必ず考慮漏れが発生し、その考慮漏れを見つけて「オメェ馬鹿じゃねーの？」というマウントをとってくる人がいますが、プロジェクト全体から見て、採用できる人数に限りがあり、なおかつオープンの場所で叱責はチームの指揮を下げます。またチームの雰囲気がだれている時にスポーツでは引き締めの言葉などを伝えて、緊張感を持たせる手法もありますが、システム開発は長期戦です、基本的にハイパフォーマンスの集中力は続きません。となると戦略的には楽しく作業することが一番いい手法になります。長距離スポーツのマラソンでも長くても3時間ですが、チーム開発は6ヶ月
や1年かかります。それ以上もかかります。なので重要なのは離脱せず、長く続くチーム力が求められます。</p>
<p>能力が低いことを指摘することを正当化する人もいますが、その方は優秀なのに、なぜGoogleやMicrosoftに行かないのですか？と逆に聞きたくなります。</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="テストの記述法"><a class="header" href="#テストの記述法">テストの記述法</a></h1>
<p>テストは、テスト以外のコードが想定された方法で機能していることを実証するRustの関数です。 テスト関数の本体は、典型的には以下の3つの動作を行います:</p>
<ol>
<li>必要なデータや状態をセットアップする。</li>
<li>テスト対象のコードを走らせる。</li>
<li>結果が想定通りであることを断定（以下、アサーションという）する。</li>
</ol>
<p>Rustが、特にこれらの動作を行うテストを書くために用意している機能を見ていきましょう。 これには、test属性、いくつかのマクロ、should_panic属性が含まれます。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
